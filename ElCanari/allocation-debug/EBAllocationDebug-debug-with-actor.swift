//
//  EBAllocationDebug-debug-auto-layout.swift
//  ElCanari-Debug
//
//  Created by Pierre Molinaro on 20/06/2021.
//
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  THIS FILE IS GENERATED BY EASY BINDINGS, DO NOT MODIFY IT
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

import Cocoa

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private let prefsEnableObjectAllocationDebugString        = "EBAllocationDebug:enableObjectAllocationDebug"
private let prefsEnableObjectAllocationStatsWindowVisible = "EBAllocationDebug:allocationStatsWindowVisible"
private let prefsEnableObjectAllocationStatsDisplayFilter = "EBAllocationDebug:allocationStatsDisplayFilter"

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private let gEnableObjectAllocationDebug = UserDefaults.standard.bool (forKey: prefsEnableObjectAllocationDebugString)

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    Public routines
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func noteObjectAllocation (_ inObject : AnyObject) {  // NOT ALWAYS IN MAIN THREAD
  if gEnableObjectAllocationDebug {
    let objectType : AnyObject.Type = type (of: inObject)
    Task {
      await PendingAllocationBufferActor.shared.noteObjectAllocation (ofType: objectType)
    }
  }
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    pmNoteObjectDeallocation
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func noteObjectDeallocation (_ inObject : AnyObject) {  // NOT ALWAYS IN MAIN THREAD
  if gEnableObjectAllocationDebug {
    let objectType : AnyObject.Type = type (of: inObject)
    Task {
      await PendingAllocationBufferActor.shared.noteObjectDeallocation (ofType: objectType)
    }
  }
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

@globalActor actor PendingAllocationBufferActor { // : GlobalActor {
  static var shared = PendingAllocationBufferActor ()
//  typealias ActorType = PendingAllocationBufferActor

  private var mPendingAllocatedObjectClasses = [AnyObject.Type] ()
  private var mPendingDeallocatedObjectClasses = [AnyObject.Type] ()
  private var mTransmitEventTriggered = false ;

  //····················································································································

  func noteObjectAllocation (ofType inType : AnyObject.Type) {
    self.mPendingAllocatedObjectClasses.append (inType)
    self.triggerTransmit ()
  }

  //····················································································································

  func noteObjectDeallocation (ofType inType : AnyObject.Type) {
    self.mPendingDeallocatedObjectClasses.append (inType)
    self.triggerTransmit ()
  }

  //····················································································································

  private func triggerTransmit () {
    if (!self.mTransmitEventTriggered) {
      self.mTransmitEventTriggered = true
      Task {
        try? await Task.sleep (nanoseconds: 100_000_000)
        let (pendingAllocations, pendingDeallocations) = await PendingAllocationBufferActor.shared.getPendingAllocation ()
        await AllocationDebugActor.shared.transmitPendingAllocations (pendingAllocations, pendingDeallocations)
      }
    }
  }

  //····················································································································

  func getPendingAllocation () -> ([AnyObject.Type], [AnyObject.Type]) {
    self.mTransmitEventTriggered = false
    let result = (self.mPendingAllocatedObjectClasses, self.mPendingDeallocatedObjectClasses)
    self.mPendingAllocatedObjectClasses.removeAll (keepingCapacity: true)
    self.mPendingDeallocatedObjectClasses.removeAll (keepingCapacity: true)
    return result
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

@globalActor actor AllocationDebugActor { // : GlobalActor {
  static var shared = AllocationDebugActor ()
//  typealias ActorType = AllocationDebugActor

  private var mTotalAllocatedObjectCountByClass = [String : Int] ()
  private var mLiveObjectCountByClass = [String : Int] ()
  private var mRefreshTriggered = false

  //····················································································································

  func transmitPendingAllocations (_ inAllocations : [AnyObject.Type], _ inDeallocations : [AnyObject.Type]) {
    for t in inAllocations {
      let className = String (describing: t)
      let currentCount = self.mTotalAllocatedObjectCountByClass [className] ?? 0
      self.mTotalAllocatedObjectCountByClass [className] = currentCount + 1
      let liveCount = self.mLiveObjectCountByClass [className] ?? 0
      self.mLiveObjectCountByClass [className] = liveCount + 1
    }
    for t in inDeallocations {
      let className = String (describing: t)
      if let n = self.mLiveObjectCountByClass [className] {
        if n > 1 {
          self.mLiveObjectCountByClass [className] = n - 1
        }else{
          self.mLiveObjectCountByClass [className] = nil
        }
      }
    }
  //---
    if !self.mRefreshTriggered {
      self.mRefreshTriggered = true
      Task {
   //     try? await Task.sleep (nanoseconds: 250_000_000) // 250 ms
        let totalAllocatedObjectCountByClass = self.mTotalAllocatedObjectCountByClass
        let liveObjectCountByClass = self.mLiveObjectCountByClass
        DispatchQueue.main.sync {
          gDebugObject?.display (totalAllocatedObjectCountByClass, liveObjectCountByClass)
        }
        self.mRefreshTriggered = false
      }
    }
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    appendAllocationDebugMenuItems
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func appendAllocationDebugMenuItems (_ inMenu : NSMenu) {
  gDebugObject = EBAllocationDebug ()
//---
  let item = NSMenuItem (
    title: "Show Allocation Stats",
    action: #selector (EBAllocationDebug.showAllocationStatWindow (_:)),
    keyEquivalent: ","
  )
  item.keyEquivalentModifierMask = [.command, .control]
  item.target = gDebugObject
  inMenu.addItem (item)
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   EBAllocationItemDisplay class
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

fileprivate struct EBAllocationItemDisplay {
  let className : String
  let allCount : Int
  let live : Int
  let snapShot : Int
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private var gDebugObject : EBAllocationDebug? = nil

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

final class EBAllocationDebug : NSObject {

  //····················································································································
  //   Properties
  //····················································································································

  private var mTotalAllocatedObjectCountByClass = [String : Int] ()
  private var mLiveObjectCountByClass = [String : Int] ()
  private var mSnapShotDictionary = [String : Int] ()

  //····················································································································

  private var mAllocationStatsDisplayFilterIndex = EBPreferencesProperty_Int (
    defaultValue: 0,
    prefKey: prefsEnableObjectAllocationStatsDisplayFilter
  )

  private var mAllocationStatsWindowVisibleAtLaunch = EBPreferencesProperty_Bool (
    defaultValue: false,
    prefKey: prefsEnableObjectAllocationStatsWindowVisible
  )

  private var mEnableAllocationDebug = EBPreferencesProperty_Bool (
    defaultValue: false,
    prefKey: prefsEnableObjectAllocationDebugString
  )

  private var mTotalAllocated = EBStoredProperty_Int (defaultValue: 0, undoManager: nil)

  private var mCurrentlyAllocated = EBStoredProperty_Int (defaultValue: 0, undoManager: nil)

  fileprivate var mAllocationStatsWindow = NSWindow (
    contentRect: NSRect(x: 0.0, y: 0.0, width: 600.0, height: 400.0),
    styleMask: [.titled, .closable, .miniaturizable],
    backing: .buffered,
    defer: true
  )

  fileprivate var mAllocationStatsWindowVisibleAtLaunchCheckbox = AutoLayoutCheckbox (
    title: "Visible At Launch",
    size: .small
  )

  fileprivate var mEnableAllocationDebugCheckbox = AutoLayoutCheckbox (
    title: "Enable Allocation Debug",
    size: .small
  )

  fileprivate var mTotalAllocatedLabel = AutoLayoutIntObserverField (bold: true, size: .small)

  fileprivate var mCurrentlyAllocatedLabel = AutoLayoutIntObserverField (bold: true, size: .small)

  fileprivate var mPerformSnapShotButton = AutoLayoutButton (title: "Snap Shot", size: .small)

  fileprivate var mFilterPopUpButton = AutoLayoutTaggedPopUpButton (size: .small)
    .add (title: "All Classes", withTag: 0)
    .add (title: "Allocated Classes", withTag: 1)
    .add (title: "Differences with Snap Shot", withTag: 2)

  fileprivate var mStatsTableView = AutoLayoutTableView (size: .small, addControlButtons: false)

  //····················································································································
  //    init
  //····················································································································

   override init () {
     super.init ()
   //--- Bindings
     _ = self.mAllocationStatsWindowVisibleAtLaunchCheckbox.bind_value (self.mAllocationStatsWindowVisibleAtLaunch)
     _ = self.mEnableAllocationDebugCheckbox.bind_value (self.mEnableAllocationDebug)
     _ = self.mTotalAllocatedLabel.bind_observedValue (self.mTotalAllocated)
     _ = self.mCurrentlyAllocatedLabel.bind_observedValue (self.mCurrentlyAllocated)
     _ = self.mPerformSnapShotButton.bind_run (target: self, selector: #selector (Self.performSnapShotAction (_:)))
     _ = self.mFilterPopUpButton.bind_selectedTag (self.mAllocationStatsDisplayFilterIndex)
       .bind_run (target: self, selector: #selector (Self.allocationStatsDisplayFilterIndexDidChange (_:)))
  //--- Configure table view
    self.mStatsTableView.configure (
      allowsEmptySelection: false,
      allowsMultipleSelection: false,
      rowCountCallBack: { [weak self] in self?.mAllocationStatsDataSource.count ?? 0 },
      delegate: nil
    )
    _ = self.mStatsTableView.setIntercellSpacing (horizontal: 0, vertical: 5)
    self.mStatsTableView.addColumn_String (
      valueGetterDelegate: { [weak self] in return self?.mAllocationStatsDataSource [$0].className ?? "" },
      valueSetterDelegate: nil,
      sortDelegate: { [weak self] (ascending) in
        self?.mAllocationStatsDataSource.sort { ascending ? ($0.className < $1.className) : ($0.className > $1.className) }
      },
      title: "Class Name",
      minWidth: 80,
      maxWidth: 1000,
      headerAlignment: .center,
      contentAlignment: .left
    )
    self.mStatsTableView.addColumn_Int (
      valueGetterDelegate: { [weak self] in return self?.mAllocationStatsDataSource [$0].snapShot ?? -1 },
      valueSetterDelegate: nil,
      sortDelegate: { [weak self] (ascending) in
        self?.mAllocationStatsDataSource.sort { ascending ? ($0.snapShot < $1.snapShot) : ($0.snapShot > $1.snapShot) }
      },
      title: "Snap Shot",
      minWidth: 80,
      maxWidth: 80,
      headerAlignment: .center,
      contentAlignment: .right
    )
    self.mStatsTableView.addColumn_Int (
      valueGetterDelegate: { [weak self] in return self?.mAllocationStatsDataSource [$0].live ?? -1 },
      valueSetterDelegate: nil,
      sortDelegate: { [weak self] (ascending) in
        self?.mAllocationStatsDataSource.sort { ascending ? ($0.live < $1.live) : ($0.live > $1.live) }
      },
      title: "Live",
      minWidth: 80,
      maxWidth: 80,
      headerAlignment: .center,
      contentAlignment: .right
    )
    self.mStatsTableView.addColumn_Int (
      valueGetterDelegate: { [weak self] in return self?.mAllocationStatsDataSource [$0].allCount ?? -1 },
      valueSetterDelegate: nil,
      sortDelegate: { [weak self] (ascending) in
        self?.mAllocationStatsDataSource.sort { ascending ? ($0.allCount < $1.allCount) : ($0.allCount > $1.allCount) }
      },
      title: "Total",
      minWidth: 80,
      maxWidth: 80,
      headerAlignment: .center,
      contentAlignment: .right
    )
   //--- Configure Window
     self.mAllocationStatsWindow.title = "Allocation Stats"
     self.mAllocationStatsWindow.isReleasedWhenClosed = false // Close button just hides the window, but do not release it
//     self.mAllocationStatsWindow.delegate = self // Will call windowDidBecomeKey: and windowWillClose:
   //--- Build window contents
      let mainVStack = AutoLayoutVerticalStackView ()
      do {
        let hStack = AutoLayoutGridView2 ().set (margins: 20).set (bottomMargin: 0)
          .addFirstBaseLineAligned (
            left: self.mEnableAllocationDebugCheckbox,
            right: AutoLayoutStaticLabel (title: "You should restart the application for this setting to take effect.", bold: true, size: .small, alignment: .center)
              .set (alignment: .left).expandableWidth ()
          )
          .addSeparator ()
        _ = mainVStack.appendView (hStack)
      }
      do {
        let hStack = AutoLayoutGridView2 ().set (margins: 20).set (topMargin: 0)
          .addFirstBaseLineAligned (
            left: AutoLayoutHorizontalStackView ().setFirstBaselineAlignment ()
              .appendView (self.mAllocationStatsWindowVisibleAtLaunchCheckbox)
              .appendFlexibleSpace (),
            right: AutoLayoutHorizontalStackView ()
              .appendFlexibleSpace ()
              .appendView (AutoLayoutStaticLabel (title: "Total Allocated", bold: true, size: .small, alignment: .center))
              .appendView (self.mTotalAllocatedLabel)
          )
          .addFirstBaseLineAligned (
            left: AutoLayoutHorizontalStackView ().setFirstBaselineAlignment ()
              .appendView (self.mPerformSnapShotButton)
              .appendView (AutoLayoutStaticLabel (title: "Display", bold: true, size: .small, alignment: .center))
              .appendView (self.mFilterPopUpButton),
            right: AutoLayoutHorizontalStackView ()
              .appendFlexibleSpace ()
              .appendView (AutoLayoutStaticLabel (title: "Currently Allocated", bold: true, size: .small, alignment: .center))
              .appendView (self.mCurrentlyAllocatedLabel)
          )
          .add (single: self.mStatsTableView)
        _ = mainVStack.appendView (hStack)
      }
    //--- Assign main view to window
      self.mAllocationStatsWindow.contentView = AutoLayoutWindowContentView (view: mainVStack)
   //--- Show Window at Launch
     if self.mAllocationStatsWindowVisibleAtLaunch.propval {
       self.mAllocationStatsWindow.makeKeyAndOrderFront (nil)
     }
  }

  //····················································································································
  //    noteObjectAllocation
  //····················································································································

  fileprivate func noteObjectAllocation (ofType inType : AnyObject.Type) {
    let className = String (describing: inType)
    let currentCount = self.mTotalAllocatedObjectCountByClass [className] ?? 0
    self.mTotalAllocatedObjectCountByClass [className] = currentCount + 1
  //---
    let liveCount = self.mLiveObjectCountByClass [className] ?? 0
    self.mLiveObjectCountByClass [className] = liveCount + 1
  //---
    self.triggerRefreshDisplay ()
  }

  //····················································································································
  //    pmNoteObjectDeallocation
  //····················································································································

  fileprivate func noteObjectDeallocation (ofType inType : AnyObject.Type) {
    let className = String (describing: inType)
    if let n = self.mLiveObjectCountByClass [className] {
      if n > 1 {
        self.mLiveObjectCountByClass [className] = n - 1
      }else{
        self.mLiveObjectCountByClass [className] = nil
      }
    }
  //---
    self.triggerRefreshDisplay ()
  }

  //····················································································································

  private var mAllocationStatsDataSource = [EBAllocationItemDisplay] ()
  private var mRefreshTriggered = false

  //····················································································································
  //    triggerRefreshDisplay
  //····················································································································

  private func triggerRefreshDisplay () {
    if !self.mRefreshTriggered {
      self.mRefreshTriggered = true
      let deadline = DispatchTime (uptimeNanoseconds: DispatchTime.now ().uptimeNanoseconds + 500_000_000)
 //     let deadline = DispatchTime.now ().advanced (by: .milliseconds (500)) // Available in 10.15
      DispatchQueue.main.asyncAfter (deadline: deadline) {
        self.mRefreshTriggered = false
        self.displayAllocation ()
      }
    }
  }

  //····················································································································

  @objc private func allocationStatsDisplayFilterIndexDidChange (_ inSender : AnyObject) {
    self.triggerRefreshDisplay ()
  }

  //····················································································································

  @objc func showAllocationStatWindow (_ inSender : AnyObject) {
    self.mAllocationStatsWindow.makeKeyAndOrderFront (inSender)
  }

  //····················································································································
  //    performSnapShotAction:
  //····················································································································

  @objc private func performSnapShotAction (_ : AnyObject) {
    self.mSnapShotDictionary = self.mLiveObjectCountByClass
    self.triggerRefreshDisplay ()
  }

  //····················································································································
  //    display
  //····················································································································

  func display (_ inTotalAllocatedObjectCountByClass : [String : Int], _ inLiveObjectCountByClass : [String : Int]) {
    self.mTotalAllocatedObjectCountByClass = inTotalAllocatedObjectCountByClass
    self.mLiveObjectCountByClass = inLiveObjectCountByClass
    self.displayAllocation ()
  }

  //····················································································································
  //    displayAllocation
  //····················································································································

  private func displayAllocation () {
    var liveObjectCount = 0
    var totalObjectCount = 0
    var array = [EBAllocationItemDisplay] ()
    for (className, totalByClass) in self.mTotalAllocatedObjectCountByClass {
      let liveByClass = self.mLiveObjectCountByClass [className] ?? 0
      let snapShotByClass = self.mSnapShotDictionary [className] ?? 0
      liveObjectCount += liveByClass
      totalObjectCount += totalByClass
      var display = true
      if 1 == self.mAllocationStatsDisplayFilterIndex.propval {
        display = liveByClass != 0 ;
      }else if 2 == self.mAllocationStatsDisplayFilterIndex.propval {
        display = liveByClass != snapShotByClass ;
      }
      if display {
        let item = EBAllocationItemDisplay (
          className: className,
          allCount: totalByClass,
          live: liveByClass,
          snapShot: snapShotByClass
        )
        array.append (item)
      }
    }
    self.mCurrentlyAllocated.setProp (liveObjectCount)
    self.mTotalAllocated.setProp (totalObjectCount)
  //---
    self.mAllocationStatsDataSource = array
    self.mStatsTableView.sortAndReloadData () // Will sort mAllocationStatsDataSource
    flushOutletEvents ()
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
