//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  THIS FILE IS GENERATED BY EASY BINDINGS, DO NOT MODIFY IT
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

import AppKit

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    Base Selection Controller AutoLayoutFontDocument characterSelection
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

@MainActor final class SelectionController_AutoLayoutFontDocument_characterSelection {

  //····················································································································

  init () {
    noteObjectAllocation (self)
  }

  //····················································································································

  deinit {
    noteObjectDeallocation (self)
  }

  //····················································································································
  //   Selection observable property: advance
  //····················································································································

  var advance_property = EBComputedProperty_Int ()

  //····················································································································
  //   Selection observable property: codePoint
  //····················································································································

  var codePoint_property = EBComputedProperty_Int ()

  //····················································································································
  //   Selection observable property: gerberCode
  //····················································································································

  var gerberCode_property = EBTransientProperty_CharacterGerberCode ()

  //····················································································································
  //   Selection observable property: gerberCodeInstructionCountMessage
  //····················································································································

  var gerberCodeInstructionCountMessage_property = EBTransientProperty_String ()

  //····················································································································
  //   Selection observable property: issues
  //····················································································································

  var issues_property = EBTransientProperty_CanariIssueArray ()

  //····················································································································
  //   Selection observable property: mWarnsWhenAdvanceIsZero
  //····················································································································

  var mWarnsWhenAdvanceIsZero_property = EBComputedProperty_Bool ()

  //····················································································································
  //   Selection observable property: mWarnsWhenNoSegment
  //····················································································································

  var mWarnsWhenNoSegment_property = EBComputedProperty_Bool ()

  //····················································································································
  //   Selection observable property: segmentArrayForDrawing
  //····················································································································

  var segmentArrayForDrawing_property = EBTransientProperty_CharacterSegmentList ()

  //····················································································································
  //   Selection observable property: segments
  //····················································································································

  //····················································································································
  //   BIND SELECTION
  //····················································································································

  private weak var mModel : ReadOnlyArrayOf_FontCharacter? = nil // SHOULD BE WEAK

  //····················································································································

  final func bind_selection (model : ReadOnlyArrayOf_FontCharacter) {
    self.mModel = model
    self.bind_property_advance (model: model)
    self.bind_property_codePoint (model: model)
    self.bind_property_gerberCode (model: model)
    self.bind_property_gerberCodeInstructionCountMessage (model: model)
    self.bind_property_issues (model: model)
    self.bind_property_mWarnsWhenAdvanceIsZero (model: model)
    self.bind_property_mWarnsWhenNoSegment (model: model)
    self.bind_property_segmentArrayForDrawing (model: model)
  }

  //····················································································································
  //   UNBIND SELECTION
  //····················································································································

  /* final func unbind_selection () {
  //--- advance
    self.advance_property.mReadModelFunction = nil 
    self.advance_property.mWriteModelFunction = nil 
    self.mModel?.toMany_advance_StopsBeingObserved (by: self.advance_property)
  //--- codePoint
    self.codePoint_property.mReadModelFunction = nil 
    self.codePoint_property.mWriteModelFunction = nil 
    self.mModel?.toMany_codePoint_StopsBeingObserved (by: self.codePoint_property)
  //--- gerberCode
    self.gerberCode_property.mReadModelFunction = nil 
    self.mModel?.toMany_gerberCode_StopsBeingObserved (by: self.gerberCode_property)
  //--- gerberCodeInstructionCountMessage
    self.gerberCodeInstructionCountMessage_property.mReadModelFunction = nil 
    self.mModel?.toMany_gerberCodeInstructionCountMessage_StopsBeingObserved (by: self.gerberCodeInstructionCountMessage_property)
  //--- issues
    self.issues_property.mReadModelFunction = nil 
    self.mModel?.toMany_issues_StopsBeingObserved (by: self.issues_property)
  //--- mWarnsWhenAdvanceIsZero
    self.mWarnsWhenAdvanceIsZero_property.mReadModelFunction = nil 
    self.mWarnsWhenAdvanceIsZero_property.mWriteModelFunction = nil 
    self.mModel?.toMany_mWarnsWhenAdvanceIsZero_StopsBeingObserved (by: self.mWarnsWhenAdvanceIsZero_property)
  //--- mWarnsWhenNoSegment
    self.mWarnsWhenNoSegment_property.mReadModelFunction = nil 
    self.mWarnsWhenNoSegment_property.mWriteModelFunction = nil 
    self.mModel?.toMany_mWarnsWhenNoSegment_StopsBeingObserved (by: self.mWarnsWhenNoSegment_property)
  //--- segmentArrayForDrawing
    self.segmentArrayForDrawing_property.mReadModelFunction = nil 
    self.mModel?.toMany_segmentArrayForDrawing_StopsBeingObserved (by: self.segmentArrayForDrawing_property)
  //---
    self.mModel = nil
  } */

  //···················································································································*

  private final func bind_property_advance (model : ReadOnlyArrayOf_FontCharacter) {
    model.toMany_advance_StartsToBeObserved (by: self.advance_property)
    self.advance_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.advance_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.advance_property.mWriteModelFunction = { [weak self] (inValue : Int) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.advance_property.setProp (inValue)
          }
        }
      }
    }
  }

  //···················································································································*

  private final func bind_property_codePoint (model : ReadOnlyArrayOf_FontCharacter) {
    model.toMany_codePoint_StartsToBeObserved (by: self.codePoint_property)
    self.codePoint_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.codePoint_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.codePoint_property.mWriteModelFunction = { [weak self] (inValue : Int) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.codePoint_property.setProp (inValue)
          }
        }
      }
    }
  }

  //···················································································································*

  private final func bind_property_gerberCode (model : ReadOnlyArrayOf_FontCharacter) {
    model.toMany_gerberCode_StartsToBeObserved (by: self.gerberCode_property)
    self.gerberCode_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <CharacterGerberCode> ()
          var isMultipleSelection = false
          for object in v {
            switch object.gerberCode_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_gerberCodeInstructionCountMessage (model : ReadOnlyArrayOf_FontCharacter) {
    model.toMany_gerberCodeInstructionCountMessage_StartsToBeObserved (by: self.gerberCodeInstructionCountMessage_property)
    self.gerberCodeInstructionCountMessage_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <String> ()
          var isMultipleSelection = false
          for object in v {
            switch object.gerberCodeInstructionCountMessage_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_issues (model : ReadOnlyArrayOf_FontCharacter) {
    model.toMany_issues_StartsToBeObserved (by: self.issues_property)
    self.issues_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <CanariIssueArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.issues_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_mWarnsWhenAdvanceIsZero (model : ReadOnlyArrayOf_FontCharacter) {
    model.toMany_mWarnsWhenAdvanceIsZero_StartsToBeObserved (by: self.mWarnsWhenAdvanceIsZero_property)
    self.mWarnsWhenAdvanceIsZero_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mWarnsWhenAdvanceIsZero_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mWarnsWhenAdvanceIsZero_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mWarnsWhenAdvanceIsZero_property.setProp (inValue)
          }
        }
      }
    }
  }

  //···················································································································*

  private final func bind_property_mWarnsWhenNoSegment (model : ReadOnlyArrayOf_FontCharacter) {
    model.toMany_mWarnsWhenNoSegment_StartsToBeObserved (by: self.mWarnsWhenNoSegment_property)
    self.mWarnsWhenNoSegment_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mWarnsWhenNoSegment_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mWarnsWhenNoSegment_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mWarnsWhenNoSegment_property.setProp (inValue)
          }
        }
      }
    }
  }

  //···················································································································*

  private final func bind_property_segmentArrayForDrawing (model : ReadOnlyArrayOf_FontCharacter) {
    model.toMany_segmentArrayForDrawing_StartsToBeObserved (by: self.segmentArrayForDrawing_property)
    self.segmentArrayForDrawing_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <CharacterSegmentList> ()
          var isMultipleSelection = false
          for object in v {
            switch object.segmentArrayForDrawing_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }



  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

