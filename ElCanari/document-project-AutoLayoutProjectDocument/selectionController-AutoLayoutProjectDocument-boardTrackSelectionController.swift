//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  THIS FILE IS GENERATED BY EASY BINDINGS, DO NOT MODIFY IT
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

import Cocoa

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    Derived selection controller AutoLayoutProjectDocument boardTrackSelectionController
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

final class SelectionController_AutoLayoutProjectDocument_boardTrackSelectionController : EBSwiftBaseObject {

  //····················································································································
  //   Selection observable property: mSide
  //····················································································································

  let mSide_property = EBPropertyProxy_TrackSide ()
  //····················································································································
  //   Selection observable property: mDefaultTrackWidthUnit
  //····················································································································

  let mDefaultTrackWidthUnit_property = EBPropertyProxy_Int ()
  //····················································································································
  //   Selection observable property: mCustomTrackWidth
  //····················································································································

  let mCustomTrackWidth_property = EBPropertyProxy_Int ()
  //····················································································································
  //   Selection observable property: mCustomTrackWidthUnit
  //····················································································································

  let mCustomTrackWidthUnit_property = EBPropertyProxy_Int ()
  //····················································································································
  //   Selection observable property: mUsesCustomTrackWidth
  //····················································································································

  let mUsesCustomTrackWidth_property = EBPropertyProxy_Bool ()
  //····················································································································
  //   Selection observable property: mIsPreservedByAutoRouter
  //····················································································································

  let mIsPreservedByAutoRouter_property = EBPropertyProxy_Bool ()
  //····················································································································
  //   Selection observable property: mP1XUnit
  //····················································································································

  let mP1XUnit_property = EBPropertyProxy_Int ()
  //····················································································································
  //   Selection observable property: mP1YUnit
  //····················································································································

  let mP1YUnit_property = EBPropertyProxy_Int ()
  //····················································································································
  //   Selection observable property: mP2XUnit
  //····················································································································

  let mP2XUnit_property = EBPropertyProxy_Int ()
  //····················································································································
  //   Selection observable property: mP2YUnit
  //····················································································································

  let mP2YUnit_property = EBPropertyProxy_Int ()
  //····················································································································
  //   Selection observable property: mManualLockP1
  //····················································································································

  let mManualLockP1_property = EBPropertyProxy_Bool ()
  //····················································································································
  //   Selection observable property: mManualLockP2
  //····················································································································

  let mManualLockP2_property = EBPropertyProxy_Bool ()
  //····················································································································
  //   Selection observable property: mDirectionLockOnKnobDragging
  //····················································································································

  let mDirectionLockOnKnobDragging_property = EBPropertyProxy_TrackLockDirection ()
  //····················································································································
  //   Selection observable property: actualTrackWidth
  //····················································································································

  let actualTrackWidth_property = EBTransientProperty_Int ()

  //····················································································································
  //   Selection observable property: netName
  //····················································································································

  let netName_property = EBTransientProperty_String ()

  //····················································································································
  //   Selection observable property: netClassName
  //····················································································································

  let netClassName_property = EBTransientProperty_String ()

  //····················································································································
  //   Selection observable property: netClassTrackWidth
  //····················································································································

  let netClassTrackWidth_property = EBTransientProperty_Int ()

  //····················································································································
  //   Selection observable property: netClassViaHoleDiameter
  //····················································································································

  let netClassViaHoleDiameter_property = EBTransientProperty_Int ()

  //····················································································································
  //   Selection observable property: netClassViaPadDiameter
  //····················································································································

  let netClassViaPadDiameter_property = EBTransientProperty_Int ()

  //····················································································································
  //   Selection observable property: trackLengthInCanariUnit
  //····················································································································

  let trackLengthInCanariUnit_property = EBTransientProperty_Double ()

  //····················································································································
  //   Selection observable property: trackSide
  //····················································································································

  let trackSide_property = EBTransientProperty_TrackSide ()

  //····················································································································
  //   Selection observable property: signatureForERCChecking
  //····················································································································

  let signatureForERCChecking_property = EBTransientProperty_UInt32 ()

  //····················································································································
  //   Selection observable property: trackDirectionInDegrees
  //····················································································································

  final let trackDirectionInDegrees_property = EBPropertyProxy_Int ()

  //····················································································································
  //   Selection observable property: p1ConnectedToSomePad
  //····················································································································

  let p1ConnectedToSomePad_property = EBTransientProperty_Bool ()

  //····················································································································
  //   Selection observable property: p2ConnectedToSomePad
  //····················································································································

  let p2ConnectedToSomePad_property = EBTransientProperty_Bool ()

  //····················································································································
  //   Selection observable property: computedP1X
  //····················································································································

  final let computedP1X_property = EBPropertyProxy_Int ()

  //····················································································································
  //   Selection observable property: computedP1Y
  //····················································································································

  final let computedP1Y_property = EBPropertyProxy_Int ()

  //····················································································································
  //   Selection observable property: computedP2X
  //····················································································································

  final let computedP2X_property = EBPropertyProxy_Int ()

  //····················································································································
  //   Selection observable property: computedP2Y
  //····················································································································

  final let computedP2Y_property = EBPropertyProxy_Int ()

  //····················································································································
  //   Selection observable property: objectDisplay
  //····················································································································

  let objectDisplay_property = EBTransientProperty_EBShape ()

  //····················································································································
  //   Selection observable property: p1CanMove
  //····················································································································

  let p1CanMove_property = EBTransientProperty_Bool ()

  //····················································································································
  //   Selection observable property: p2CanMove
  //····················································································································

  let p2CanMove_property = EBTransientProperty_Bool ()

  //····················································································································
  //   Selection observable property: trackCanRotate
  //····················································································································

  let trackCanRotate_property = EBTransientProperty_Bool ()

  //····················································································································
  //   Selection observable property: selectionDisplay
  //····················································································································

  let selectionDisplay_property = EBTransientProperty_EBShape ()

  //····················································································································
  //   Selected array (not observable)
  //····················································································································

  var selectedArray : EBReferenceArray <BoardTrack> { return self.selectedArray_property.propval }

  //····················································································································
  //   BIND SELECTION
  //····················································································································

   let selectedArray_property = TransientArrayOfSuperOf_BoardTrack <BoardObject> ()

  //····················································································································

  final func bind_selection (model : ReadOnlyArrayOf_BoardObject) {
    self.selectedArray_property.setDataProvider (model)
    self.bind_property_mSide ()
    self.bind_property_mDefaultTrackWidthUnit ()
    self.bind_property_mCustomTrackWidth ()
    self.bind_property_mCustomTrackWidthUnit ()
    self.bind_property_mUsesCustomTrackWidth ()
    self.bind_property_mIsPreservedByAutoRouter ()
    self.bind_property_mP1XUnit ()
    self.bind_property_mP1YUnit ()
    self.bind_property_mP2XUnit ()
    self.bind_property_mP2YUnit ()
    self.bind_property_mManualLockP1 ()
    self.bind_property_mManualLockP2 ()
    self.bind_property_mDirectionLockOnKnobDragging ()
    self.bind_property_actualTrackWidth ()
    self.bind_property_netName ()
    self.bind_property_netClassName ()
    self.bind_property_netClassTrackWidth ()
    self.bind_property_netClassViaHoleDiameter ()
    self.bind_property_netClassViaPadDiameter ()
    self.bind_property_trackLengthInCanariUnit ()
    self.bind_property_trackSide ()
    self.bind_property_signatureForERCChecking ()
    self.bind_property_trackDirectionInDegrees ()
    self.bind_property_p1ConnectedToSomePad ()
    self.bind_property_p2ConnectedToSomePad ()
    self.bind_property_computedP1X ()
    self.bind_property_computedP1Y ()
    self.bind_property_computedP2X ()
    self.bind_property_computedP2Y ()
    self.bind_property_objectDisplay ()
    self.bind_property_p1CanMove ()
    self.bind_property_p2CanMove ()
    self.bind_property_trackCanRotate ()
    self.bind_property_selectionDisplay ()
  }

  //····················································································································
  //   UNBIND SELECTION
  //····················································································································

  final func unbind_selection () {
    self.selectedArray_property.setDataProvider (nil)
  //--- mSide
    self.mSide_property.mReadModelFunction = nil 
    self.mSide_property.mWriteModelFunction = nil 
    self.mSide_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mSide (self.mSide_property)
  //--- mDefaultTrackWidthUnit
    self.mDefaultTrackWidthUnit_property.mReadModelFunction = nil 
    self.mDefaultTrackWidthUnit_property.mWriteModelFunction = nil 
    self.mDefaultTrackWidthUnit_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mDefaultTrackWidthUnit (self.mDefaultTrackWidthUnit_property)
  //--- mCustomTrackWidth
    self.mCustomTrackWidth_property.mReadModelFunction = nil 
    self.mCustomTrackWidth_property.mWriteModelFunction = nil 
    self.mCustomTrackWidth_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mCustomTrackWidth (self.mCustomTrackWidth_property)
  //--- mCustomTrackWidthUnit
    self.mCustomTrackWidthUnit_property.mReadModelFunction = nil 
    self.mCustomTrackWidthUnit_property.mWriteModelFunction = nil 
    self.mCustomTrackWidthUnit_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mCustomTrackWidthUnit (self.mCustomTrackWidthUnit_property)
  //--- mUsesCustomTrackWidth
    self.mUsesCustomTrackWidth_property.mReadModelFunction = nil 
    self.mUsesCustomTrackWidth_property.mWriteModelFunction = nil 
    self.mUsesCustomTrackWidth_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mUsesCustomTrackWidth (self.mUsesCustomTrackWidth_property)
  //--- mIsPreservedByAutoRouter
    self.mIsPreservedByAutoRouter_property.mReadModelFunction = nil 
    self.mIsPreservedByAutoRouter_property.mWriteModelFunction = nil 
    self.mIsPreservedByAutoRouter_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mIsPreservedByAutoRouter (self.mIsPreservedByAutoRouter_property)
  //--- mP1XUnit
    self.mP1XUnit_property.mReadModelFunction = nil 
    self.mP1XUnit_property.mWriteModelFunction = nil 
    self.mP1XUnit_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mP1XUnit (self.mP1XUnit_property)
  //--- mP1YUnit
    self.mP1YUnit_property.mReadModelFunction = nil 
    self.mP1YUnit_property.mWriteModelFunction = nil 
    self.mP1YUnit_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mP1YUnit (self.mP1YUnit_property)
  //--- mP2XUnit
    self.mP2XUnit_property.mReadModelFunction = nil 
    self.mP2XUnit_property.mWriteModelFunction = nil 
    self.mP2XUnit_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mP2XUnit (self.mP2XUnit_property)
  //--- mP2YUnit
    self.mP2YUnit_property.mReadModelFunction = nil 
    self.mP2YUnit_property.mWriteModelFunction = nil 
    self.mP2YUnit_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mP2YUnit (self.mP2YUnit_property)
  //--- mManualLockP1
    self.mManualLockP1_property.mReadModelFunction = nil 
    self.mManualLockP1_property.mWriteModelFunction = nil 
    self.mManualLockP1_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mManualLockP1 (self.mManualLockP1_property)
  //--- mManualLockP2
    self.mManualLockP2_property.mReadModelFunction = nil 
    self.mManualLockP2_property.mWriteModelFunction = nil 
    self.mManualLockP2_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mManualLockP2 (self.mManualLockP2_property)
  //--- mDirectionLockOnKnobDragging
    self.mDirectionLockOnKnobDragging_property.mReadModelFunction = nil 
    self.mDirectionLockOnKnobDragging_property.mWriteModelFunction = nil 
    self.mDirectionLockOnKnobDragging_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mDirectionLockOnKnobDragging (self.mDirectionLockOnKnobDragging_property)
  //--- actualTrackWidth
    self.actualTrackWidth_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_actualTrackWidth (self.actualTrackWidth_property)
  //--- netName
    self.netName_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_netName (self.netName_property)
  //--- netClassName
    self.netClassName_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_netClassName (self.netClassName_property)
  //--- netClassTrackWidth
    self.netClassTrackWidth_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_netClassTrackWidth (self.netClassTrackWidth_property)
  //--- netClassViaHoleDiameter
    self.netClassViaHoleDiameter_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_netClassViaHoleDiameter (self.netClassViaHoleDiameter_property)
  //--- netClassViaPadDiameter
    self.netClassViaPadDiameter_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_netClassViaPadDiameter (self.netClassViaPadDiameter_property)
  //--- trackLengthInCanariUnit
    self.trackLengthInCanariUnit_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_trackLengthInCanariUnit (self.trackLengthInCanariUnit_property)
  //--- trackSide
    self.trackSide_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_trackSide (self.trackSide_property)
  //--- signatureForERCChecking
    self.signatureForERCChecking_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_signatureForERCChecking (self.signatureForERCChecking_property)
  //--- trackDirectionInDegrees
    self.trackDirectionInDegrees_property.mReadModelFunction = nil 
    self.trackDirectionInDegrees_property.mWriteModelFunction = nil 
    self.trackDirectionInDegrees_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_trackDirectionInDegrees (self.trackDirectionInDegrees_property)
  //--- p1ConnectedToSomePad
    self.p1ConnectedToSomePad_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_p1ConnectedToSomePad (self.p1ConnectedToSomePad_property)
  //--- p2ConnectedToSomePad
    self.p2ConnectedToSomePad_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_p2ConnectedToSomePad (self.p2ConnectedToSomePad_property)
  //--- computedP1X
    self.computedP1X_property.mReadModelFunction = nil 
    self.computedP1X_property.mWriteModelFunction = nil 
    self.computedP1X_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_computedP1X (self.computedP1X_property)
  //--- computedP1Y
    self.computedP1Y_property.mReadModelFunction = nil 
    self.computedP1Y_property.mWriteModelFunction = nil 
    self.computedP1Y_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_computedP1Y (self.computedP1Y_property)
  //--- computedP2X
    self.computedP2X_property.mReadModelFunction = nil 
    self.computedP2X_property.mWriteModelFunction = nil 
    self.computedP2X_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_computedP2X (self.computedP2X_property)
  //--- computedP2Y
    self.computedP2Y_property.mReadModelFunction = nil 
    self.computedP2Y_property.mWriteModelFunction = nil 
    self.computedP2Y_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_computedP2Y (self.computedP2Y_property)
  //--- objectDisplay
    self.objectDisplay_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_objectDisplay (self.objectDisplay_property)
  //--- p1CanMove
    self.p1CanMove_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_p1CanMove (self.p1CanMove_property)
  //--- p2CanMove
    self.p2CanMove_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_p2CanMove (self.p2CanMove_property)
  //--- trackCanRotate
    self.trackCanRotate_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_trackCanRotate (self.trackCanRotate_property)
  //--- selectionDisplay
    self.selectionDisplay_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_selectionDisplay (self.selectionDisplay_property)
  }

  //····················································································································
  //    Explorer
  //····················································································································

  #if BUILD_OBJECT_EXPLORER
    private var mValueExplorer : NSButton?
    private var mExplorerWindow : NSWindow?
  #endif

  //····················································································································

  #if BUILD_OBJECT_EXPLORER
    final func addExplorer (name : String, y : inout CGFloat, view : NSView) {
      let font = NSFont.boldSystemFont (ofSize: NSFont.smallSystemFontSize)
      let tf = NSTextField (frame:secondColumn (y))
      tf.isEnabled = true
      tf.isEditable = false
      tf.stringValue = name
      tf.font = font
      view.addSubview (tf)
      let valueExplorer = NSButton (frame: thirdColumn (y))
      valueExplorer.font = font
      valueExplorer.title = self.explorerIndexString + " " + String (describing: type (of: self))
      valueExplorer.target = self
      valueExplorer.action = #selector(SelectionController_AutoLayoutProjectDocument_boardTrackSelectionController.showObjectWindowFromExplorerButton(_:))
      view.addSubview (valueExplorer)
      self.mValueExplorer = valueExplorer
      y += EXPLORER_ROW_HEIGHT
    }
  #endif

  //····················································································································

  #if BUILD_OBJECT_EXPLORER
    func buildExplorerWindow () {
    //-------------------------------------------------- Create Window
      let r = NSRect (x: 20.0, y: 20.0, width: 10.0, height: 10.0)
      self.mExplorerWindow = NSWindow (contentRect: r, styleMask: [.titled, .closable], backing: .buffered, defer: true, screen: nil)
    //-------------------------------------------------- Adding properties
      let view = NSView (frame: r)
      var y : CGFloat = 0.0
      createEntryForPropertyNamed (
        "mSide",
        object: self.mSide_property,
        y: &y,
        view: view,
        observerExplorer: &self.mSide_property.mObserverExplorer,
        valueExplorer: &self.mSide_property.mValueExplorer
      )
      createEntryForPropertyNamed (
        "mDefaultTrackWidthUnit",
        object: self.mDefaultTrackWidthUnit_property,
        y: &y,
        view: view,
        observerExplorer: &self.mDefaultTrackWidthUnit_property.mObserverExplorer,
        valueExplorer: &self.mDefaultTrackWidthUnit_property.mValueExplorer
      )
      createEntryForPropertyNamed (
        "mCustomTrackWidth",
        object: self.mCustomTrackWidth_property,
        y: &y,
        view: view,
        observerExplorer: &self.mCustomTrackWidth_property.mObserverExplorer,
        valueExplorer: &self.mCustomTrackWidth_property.mValueExplorer
      )
      createEntryForPropertyNamed (
        "mCustomTrackWidthUnit",
        object: self.mCustomTrackWidthUnit_property,
        y: &y,
        view: view,
        observerExplorer: &self.mCustomTrackWidthUnit_property.mObserverExplorer,
        valueExplorer: &self.mCustomTrackWidthUnit_property.mValueExplorer
      )
      createEntryForPropertyNamed (
        "mUsesCustomTrackWidth",
        object: self.mUsesCustomTrackWidth_property,
        y: &y,
        view: view,
        observerExplorer: &self.mUsesCustomTrackWidth_property.mObserverExplorer,
        valueExplorer: &self.mUsesCustomTrackWidth_property.mValueExplorer
      )
      createEntryForPropertyNamed (
        "mIsPreservedByAutoRouter",
        object: self.mIsPreservedByAutoRouter_property,
        y: &y,
        view: view,
        observerExplorer: &self.mIsPreservedByAutoRouter_property.mObserverExplorer,
        valueExplorer: &self.mIsPreservedByAutoRouter_property.mValueExplorer
      )
      createEntryForPropertyNamed (
        "mP1XUnit",
        object: self.mP1XUnit_property,
        y: &y,
        view: view,
        observerExplorer: &self.mP1XUnit_property.mObserverExplorer,
        valueExplorer: &self.mP1XUnit_property.mValueExplorer
      )
      createEntryForPropertyNamed (
        "mP1YUnit",
        object: self.mP1YUnit_property,
        y: &y,
        view: view,
        observerExplorer: &self.mP1YUnit_property.mObserverExplorer,
        valueExplorer: &self.mP1YUnit_property.mValueExplorer
      )
      createEntryForPropertyNamed (
        "mP2XUnit",
        object: self.mP2XUnit_property,
        y: &y,
        view: view,
        observerExplorer: &self.mP2XUnit_property.mObserverExplorer,
        valueExplorer: &self.mP2XUnit_property.mValueExplorer
      )
      createEntryForPropertyNamed (
        "mP2YUnit",
        object: self.mP2YUnit_property,
        y: &y,
        view: view,
        observerExplorer: &self.mP2YUnit_property.mObserverExplorer,
        valueExplorer: &self.mP2YUnit_property.mValueExplorer
      )
      createEntryForPropertyNamed (
        "mManualLockP1",
        object: self.mManualLockP1_property,
        y: &y,
        view: view,
        observerExplorer: &self.mManualLockP1_property.mObserverExplorer,
        valueExplorer: &self.mManualLockP1_property.mValueExplorer
      )
      createEntryForPropertyNamed (
        "mManualLockP2",
        object: self.mManualLockP2_property,
        y: &y,
        view: view,
        observerExplorer: &self.mManualLockP2_property.mObserverExplorer,
        valueExplorer: &self.mManualLockP2_property.mValueExplorer
      )
      createEntryForPropertyNamed (
        "mDirectionLockOnKnobDragging",
        object: self.mDirectionLockOnKnobDragging_property,
        y: &y,
        view: view,
        observerExplorer: &self.mDirectionLockOnKnobDragging_property.mObserverExplorer,
        valueExplorer: &self.mDirectionLockOnKnobDragging_property.mValueExplorer
      )
    //-------------------------------------------------- Finish Window construction
    //--- Resize View
      let viewFrame = NSRect (x: 0.0, y: 0.0, width: EXPLORER_ROW_WIDTH, height: y)
      view.frame = viewFrame
    //--- Set content size
      self.mExplorerWindow?.setContentSize (NSSize (width: EXPLORER_ROW_WIDTH + 16.0, height: fmin (600.0, y)))
    //--- Set close button as 'remove window' button
      let closeButton : NSButton? = self.mExplorerWindow?.standardWindowButton (.closeButton)
      closeButton?.target = self
      closeButton?.action = #selector(SelectionController_AutoLayoutProjectDocument_boardTrackSelectionController.deleteSelectionControllerWindowAction(_:))
    //--- Set window title
      let windowTitle = self.explorerIndexString + " " + String (describing: type (of: self))
      self.mExplorerWindow!.title = windowTitle
    //--- Add Scroll view
      let frame = NSRect (x: 0.0, y: 0.0, width: EXPLORER_ROW_WIDTH, height: y)
      let sw = NSScrollView (frame: frame)
      sw.hasVerticalScroller = true
      sw.documentView = view
      self.mExplorerWindow!.contentView = sw
    }
  #endif
  
  //····················································································································
  //   showObjectWindowFromExplorerButton
  //····················································································································

  #if BUILD_OBJECT_EXPLORER
    @objc func showObjectWindowFromExplorerButton (_ : Any) {
      if self.mExplorerWindow == nil {
        self.buildExplorerWindow ()
      }
      self.mExplorerWindow?.makeKeyAndOrderFront (nil)
    }
  #endif
  
  //····················································································································
  //   deleteSelectionControllerWindowAction
  //····················································································································

  #if BUILD_OBJECT_EXPLORER
    @objc func deleteSelectionControllerWindowAction (_ : Any) {
      self.clearObjectExplorer ()
    }
  #endif

  //····················································································································
  //   clearObjectExplorer
  //····················································································································

  #if BUILD_OBJECT_EXPLORER
    func clearObjectExplorer () {
      if let closeButton = self.mExplorerWindow?.standardWindowButton (.closeButton) {
        closeButton.target = nil
      }
      self.mExplorerWindow?.orderOut (nil)
      self.mExplorerWindow = nil
    }
  #endif

  //····················································································································

  private final func bind_property_mSide () {
    self.selectedArray_property.addEBObserverOf_mSide (self.mSide_property)
    self.mSide_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <TrackSide> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mSide_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mSide_property.mWriteModelFunction = { [weak self] (inValue : TrackSide) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mSide_property.setProp (inValue)
          }
        }
      }
    }
    self.mSide_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : TrackSide, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mSide_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mDefaultTrackWidthUnit () {
    self.selectedArray_property.addEBObserverOf_mDefaultTrackWidthUnit (self.mDefaultTrackWidthUnit_property)
    self.mDefaultTrackWidthUnit_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mDefaultTrackWidthUnit_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mDefaultTrackWidthUnit_property.mWriteModelFunction = { [weak self] (inValue : Int) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mDefaultTrackWidthUnit_property.setProp (inValue)
          }
        }
      }
    }
    self.mDefaultTrackWidthUnit_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mDefaultTrackWidthUnit_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mCustomTrackWidth () {
    self.selectedArray_property.addEBObserverOf_mCustomTrackWidth (self.mCustomTrackWidth_property)
    self.mCustomTrackWidth_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mCustomTrackWidth_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mCustomTrackWidth_property.mWriteModelFunction = { [weak self] (inValue : Int) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mCustomTrackWidth_property.setProp (inValue)
          }
        }
      }
    }
    self.mCustomTrackWidth_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mCustomTrackWidth_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mCustomTrackWidthUnit () {
    self.selectedArray_property.addEBObserverOf_mCustomTrackWidthUnit (self.mCustomTrackWidthUnit_property)
    self.mCustomTrackWidthUnit_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mCustomTrackWidthUnit_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mCustomTrackWidthUnit_property.mWriteModelFunction = { [weak self] (inValue : Int) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mCustomTrackWidthUnit_property.setProp (inValue)
          }
        }
      }
    }
    self.mCustomTrackWidthUnit_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mCustomTrackWidthUnit_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mUsesCustomTrackWidth () {
    self.selectedArray_property.addEBObserverOf_mUsesCustomTrackWidth (self.mUsesCustomTrackWidth_property)
    self.mUsesCustomTrackWidth_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mUsesCustomTrackWidth_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mUsesCustomTrackWidth_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mUsesCustomTrackWidth_property.setProp (inValue)
          }
        }
      }
    }
    self.mUsesCustomTrackWidth_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mUsesCustomTrackWidth_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mIsPreservedByAutoRouter () {
    self.selectedArray_property.addEBObserverOf_mIsPreservedByAutoRouter (self.mIsPreservedByAutoRouter_property)
    self.mIsPreservedByAutoRouter_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mIsPreservedByAutoRouter_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mIsPreservedByAutoRouter_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mIsPreservedByAutoRouter_property.setProp (inValue)
          }
        }
      }
    }
    self.mIsPreservedByAutoRouter_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mIsPreservedByAutoRouter_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mP1XUnit () {
    self.selectedArray_property.addEBObserverOf_mP1XUnit (self.mP1XUnit_property)
    self.mP1XUnit_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mP1XUnit_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mP1XUnit_property.mWriteModelFunction = { [weak self] (inValue : Int) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mP1XUnit_property.setProp (inValue)
          }
        }
      }
    }
    self.mP1XUnit_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mP1XUnit_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mP1YUnit () {
    self.selectedArray_property.addEBObserverOf_mP1YUnit (self.mP1YUnit_property)
    self.mP1YUnit_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mP1YUnit_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mP1YUnit_property.mWriteModelFunction = { [weak self] (inValue : Int) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mP1YUnit_property.setProp (inValue)
          }
        }
      }
    }
    self.mP1YUnit_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mP1YUnit_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mP2XUnit () {
    self.selectedArray_property.addEBObserverOf_mP2XUnit (self.mP2XUnit_property)
    self.mP2XUnit_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mP2XUnit_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mP2XUnit_property.mWriteModelFunction = { [weak self] (inValue : Int) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mP2XUnit_property.setProp (inValue)
          }
        }
      }
    }
    self.mP2XUnit_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mP2XUnit_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mP2YUnit () {
    self.selectedArray_property.addEBObserverOf_mP2YUnit (self.mP2YUnit_property)
    self.mP2YUnit_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mP2YUnit_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mP2YUnit_property.mWriteModelFunction = { [weak self] (inValue : Int) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mP2YUnit_property.setProp (inValue)
          }
        }
      }
    }
    self.mP2YUnit_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mP2YUnit_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mManualLockP1 () {
    self.selectedArray_property.addEBObserverOf_mManualLockP1 (self.mManualLockP1_property)
    self.mManualLockP1_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mManualLockP1_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mManualLockP1_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mManualLockP1_property.setProp (inValue)
          }
        }
      }
    }
    self.mManualLockP1_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mManualLockP1_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mManualLockP2 () {
    self.selectedArray_property.addEBObserverOf_mManualLockP2 (self.mManualLockP2_property)
    self.mManualLockP2_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mManualLockP2_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mManualLockP2_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mManualLockP2_property.setProp (inValue)
          }
        }
      }
    }
    self.mManualLockP2_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mManualLockP2_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mDirectionLockOnKnobDragging () {
    self.selectedArray_property.addEBObserverOf_mDirectionLockOnKnobDragging (self.mDirectionLockOnKnobDragging_property)
    self.mDirectionLockOnKnobDragging_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <TrackLockDirection> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mDirectionLockOnKnobDragging_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mDirectionLockOnKnobDragging_property.mWriteModelFunction = { [weak self] (inValue : TrackLockDirection) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mDirectionLockOnKnobDragging_property.setProp (inValue)
          }
        }
      }
    }
    self.mDirectionLockOnKnobDragging_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : TrackLockDirection, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mDirectionLockOnKnobDragging_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_actualTrackWidth () {
    self.selectedArray_property.addEBObserverOf_actualTrackWidth (self.actualTrackWidth_property)
    self.actualTrackWidth_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.actualTrackWidth_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_netName () {
    self.selectedArray_property.addEBObserverOf_netName (self.netName_property)
    self.netName_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <String> ()
          var isMultipleSelection = false
          for object in v {
            switch object.netName_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_netClassName () {
    self.selectedArray_property.addEBObserverOf_netClassName (self.netClassName_property)
    self.netClassName_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <String> ()
          var isMultipleSelection = false
          for object in v {
            switch object.netClassName_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_netClassTrackWidth () {
    self.selectedArray_property.addEBObserverOf_netClassTrackWidth (self.netClassTrackWidth_property)
    self.netClassTrackWidth_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.netClassTrackWidth_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_netClassViaHoleDiameter () {
    self.selectedArray_property.addEBObserverOf_netClassViaHoleDiameter (self.netClassViaHoleDiameter_property)
    self.netClassViaHoleDiameter_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.netClassViaHoleDiameter_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_netClassViaPadDiameter () {
    self.selectedArray_property.addEBObserverOf_netClassViaPadDiameter (self.netClassViaPadDiameter_property)
    self.netClassViaPadDiameter_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.netClassViaPadDiameter_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_trackLengthInCanariUnit () {
    self.selectedArray_property.addEBObserverOf_trackLengthInCanariUnit (self.trackLengthInCanariUnit_property)
    self.trackLengthInCanariUnit_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Double> ()
          var isMultipleSelection = false
          for object in v {
            switch object.trackLengthInCanariUnit_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_trackSide () {
    self.selectedArray_property.addEBObserverOf_trackSide (self.trackSide_property)
    self.trackSide_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <TrackSide> ()
          var isMultipleSelection = false
          for object in v {
            switch object.trackSide_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_signatureForERCChecking () {
    self.selectedArray_property.addEBObserverOf_signatureForERCChecking (self.signatureForERCChecking_property)
    self.signatureForERCChecking_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <UInt32> ()
          var isMultipleSelection = false
          for object in v {
            switch object.signatureForERCChecking_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_trackDirectionInDegrees () {
    self.selectedArray_property.addEBObserverOf_trackDirectionInDegrees (self.trackDirectionInDegrees_property)
    self.trackDirectionInDegrees_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.trackDirectionInDegrees_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.trackDirectionInDegrees_property.mWriteModelFunction = { [weak self] (inValue : Int) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.trackDirectionInDegrees_property.setProp (inValue)
          }
        }
      }
    }
    self.trackDirectionInDegrees_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.trackDirectionInDegrees_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_p1ConnectedToSomePad () {
    self.selectedArray_property.addEBObserverOf_p1ConnectedToSomePad (self.p1ConnectedToSomePad_property)
    self.p1ConnectedToSomePad_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.p1ConnectedToSomePad_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_p2ConnectedToSomePad () {
    self.selectedArray_property.addEBObserverOf_p2ConnectedToSomePad (self.p2ConnectedToSomePad_property)
    self.p2ConnectedToSomePad_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.p2ConnectedToSomePad_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_computedP1X () {
    self.selectedArray_property.addEBObserverOf_computedP1X (self.computedP1X_property)
    self.computedP1X_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.computedP1X_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.computedP1X_property.mWriteModelFunction = { [weak self] (inValue : Int) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.computedP1X_property.setProp (inValue)
          }
        }
      }
    }
    self.computedP1X_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.computedP1X_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_computedP1Y () {
    self.selectedArray_property.addEBObserverOf_computedP1Y (self.computedP1Y_property)
    self.computedP1Y_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.computedP1Y_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.computedP1Y_property.mWriteModelFunction = { [weak self] (inValue : Int) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.computedP1Y_property.setProp (inValue)
          }
        }
      }
    }
    self.computedP1Y_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.computedP1Y_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_computedP2X () {
    self.selectedArray_property.addEBObserverOf_computedP2X (self.computedP2X_property)
    self.computedP2X_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.computedP2X_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.computedP2X_property.mWriteModelFunction = { [weak self] (inValue : Int) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.computedP2X_property.setProp (inValue)
          }
        }
      }
    }
    self.computedP2X_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.computedP2X_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_computedP2Y () {
    self.selectedArray_property.addEBObserverOf_computedP2Y (self.computedP2Y_property)
    self.computedP2Y_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.computedP2Y_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.computedP2Y_property.mWriteModelFunction = { [weak self] (inValue : Int) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.computedP2Y_property.setProp (inValue)
          }
        }
      }
    }
    self.computedP2Y_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.computedP2Y_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_objectDisplay () {
    self.selectedArray_property.addEBObserverOf_objectDisplay (self.objectDisplay_property)
    self.objectDisplay_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <EBShape> ()
          var isMultipleSelection = false
          for object in v {
            switch object.objectDisplay_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_p1CanMove () {
    self.selectedArray_property.addEBObserverOf_p1CanMove (self.p1CanMove_property)
    self.p1CanMove_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.p1CanMove_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_p2CanMove () {
    self.selectedArray_property.addEBObserverOf_p2CanMove (self.p2CanMove_property)
    self.p2CanMove_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.p2CanMove_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_trackCanRotate () {
    self.selectedArray_property.addEBObserverOf_trackCanRotate (self.trackCanRotate_property)
    self.trackCanRotate_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.trackCanRotate_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_selectionDisplay () {
    self.selectedArray_property.addEBObserverOf_selectionDisplay (self.selectionDisplay_property)
    self.selectionDisplay_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <EBShape> ()
          var isMultipleSelection = false
          for object in v {
            switch object.selectionDisplay_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }


  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

