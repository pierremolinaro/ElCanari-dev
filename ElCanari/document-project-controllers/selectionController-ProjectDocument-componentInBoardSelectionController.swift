//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  THIS FILE IS GENERATED BY EASY BINDINGS, DO NOT MODIFY IT
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

import Cocoa

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    Derived selection controller ProjectDocument componentInBoardSelectionController
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

final class SelectionController_ProjectDocument_componentInBoardSelectionController : EBSwiftBaseObject {

  //····················································································································
  //   Selection observable property: mSlavePadsShouldBeRouted
  //····················································································································

  let mSlavePadsShouldBeRouted_property = EBPropertyProxy_Bool ()
  //····················································································································
  //   Selection observable property: mX
  //····················································································································

  let mX_property = EBPropertyProxy_Int ()
  //····················································································································
  //   Selection observable property: mY
  //····················································································································

  let mY_property = EBPropertyProxy_Int ()
  //····················································································································
  //   Selection observable property: mRotation
  //····················································································································

  let mRotation_property = EBPropertyProxy_Int ()
  //····················································································································
  //   Selection observable property: mSide
  //····················································································································

  let mSide_property = EBPropertyProxy_ComponentSide ()
  //····················································································································
  //   Selection observable property: mDisplayLegend
  //····················································································································

  let mDisplayLegend_property = EBPropertyProxy_Bool ()
  //····················································································································
  //   Selection observable property: mNameIsVisibleInBoard
  //····················································································································

  let mNameIsVisibleInBoard_property = EBPropertyProxy_Bool ()
  //····················································································································
  //   Selection observable property: mXName
  //····················································································································

  let mXName_property = EBPropertyProxy_Int ()
  //····················································································································
  //   Selection observable property: mYName
  //····················································································································

  let mYName_property = EBPropertyProxy_Int ()
  //····················································································································
  //   Selection observable property: mNameFontSize
  //····················································································································

  let mNameFontSize_property = EBPropertyProxy_Double ()
  //····················································································································
  //   Selection observable property: mNameRotation
  //····················································································································

  let mNameRotation_property = EBPropertyProxy_Int ()
  //····················································································································
  //   Selection observable property: mValueIsVisibleInBoard
  //····················································································································

  let mValueIsVisibleInBoard_property = EBPropertyProxy_Bool ()
  //····················································································································
  //   Selection observable property: mXValue
  //····················································································································

  let mXValue_property = EBPropertyProxy_Int ()
  //····················································································································
  //   Selection observable property: mYValue
  //····················································································································

  let mYValue_property = EBPropertyProxy_Int ()
  //····················································································································
  //   Selection observable property: mValueFontSize
  //····················································································································

  let mValueFontSize_property = EBPropertyProxy_Double ()
  //····················································································································
  //   Selection observable property: mValueRotation
  //····················································································································

  let mValueRotation_property = EBPropertyProxy_Int ()
  //····················································································································
  //   Selection observable property: mComponentValue
  //····················································································································

  let mComponentValue_property = EBPropertyProxy_String ()
  //····················································································································
  //   Selection observable property: mNamePrefix
  //····················································································································

  let mNamePrefix_property = EBPropertyProxy_String ()
  //····················································································································
  //   Selection observable property: mNameIndex
  //····················································································································

  let mNameIndex_property = EBPropertyProxy_Int ()
  //····················································································································
  //   Selection observable property: mXUnit
  //····················································································································

  let mXUnit_property = EBPropertyProxy_Int ()
  //····················································································································
  //   Selection observable property: mYUnit
  //····················································································································

  let mYUnit_property = EBPropertyProxy_Int ()
  //····················································································································
  //   ToMany proxy: mPackages
  //····················································································································

  let mPackages_property = ProxyArrayOf_DevicePackageInProject ()

  //····················································································································
  //   Selection observable property: deviceName
  //····················································································································

  let deviceName_property = EBTransientProperty_String ()

  //····················································································································
  //   Selection observable property: signatureForERCChecking
  //····················································································································

  let signatureForERCChecking_property = EBTransientProperty_UInt32 ()

  //····················································································································
  //   Selection observable property: packagePadDictionary
  //····················································································································

  let packagePadDictionary_property = EBTransientProperty_PackageMasterPadDictionary ()

  //····················································································································
  //   Selection observable property: selectedPackageName
  //····················································································································

  let selectedPackageName_property = EBTransientProperty_String ()

  //····················································································································
  //   Selection observable property: availablePackages
  //····················································································································

  let availablePackages_property = EBTransientProperty_StringArray ()

  //····················································································································
  //   Selection observable property: issues
  //····················································································································

  let issues_property = EBTransientProperty_CanariIssueArray ()

  //····················································································································
  //   Selection observable property: componentIsPlacedInBoard
  //····················································································································

  let componentIsPlacedInBoard_property = EBTransientProperty_Bool ()

  //····················································································································
  //   Selection observable property: componentIsPlacedInBoardString
  //····················································································································

  let componentIsPlacedInBoardString_property = EBTransientProperty_String ()

  //····················································································································
  //   Selection observable property: strokeBezierPath
  //····················································································································

  let strokeBezierPath_property = EBTransientProperty_EBBezierPath ()

  //····················································································································
  //   Selection observable property: pinPadAssignments
  //····················································································································

  let pinPadAssignments_property = EBTransientProperty_ThreeStringArray ()

  //····················································································································
  //   Selection observable property: hasSlavePads
  //····················································································································

  let hasSlavePads_property = EBTransientProperty_Bool ()

  //····················································································································
  //   Selection observable property: placementInSchematic
  //····················································································································

  let placementInSchematic_property = EBTransientProperty_String ()

  //····················································································································
  //   Selection observable property: deviceSymbolDictionary
  //····················································································································

  let deviceSymbolDictionary_property = EBTransientProperty_DeviceSymbolDictionary ()

  //····················································································································
  //   Selection observable property: componentNameFontName
  //····················································································································

  let componentNameFontName_property = EBTransientProperty_String ()

  //····················································································································
  //   Selection observable property: componentValueFontName
  //····················································································································

  let componentValueFontName_property = EBTransientProperty_String ()

  //····················································································································
  //   Selection observable property: componentPadDictionary
  //····················································································································

  let componentPadDictionary_property = EBTransientProperty_ComponentPadDescriptorDictionary ()

  //····················································································································
  //   Selection observable property: padNetDictionary
  //····················································································································

  let padNetDictionary_property = EBTransientProperty_PadNetDictionary ()

  //····················································································································
  //   Selection observable property: componentName
  //····················································································································

  let componentName_property = EBTransientProperty_String ()

  //····················································································································
  //   Selection observable property: selectionDisplay
  //····················································································································

  let selectionDisplay_property = EBTransientProperty_EBShape ()

  //····················································································································
  //   Selection observable property: unplacedSymbols
  //····················································································································

  let unplacedSymbols_property = EBTransientProperty_StringTagArray ()

  //····················································································································
  //   Selection observable property: objectDisplay
  //····················································································································

  let objectDisplay_property = EBTransientProperty_EBShape ()

  //····················································································································
  //   Selected array (not observable)
  //····················································································································

  var selectedArray : EBReferenceArray  <ComponentInProject> { return self.selectedArray_property.propval }

  //····················································································································
  //   BIND SELECTION
  //····················································································································

   let selectedArray_property = TransientArrayOfSuperOf_ComponentInProject <BoardObject> ()

  //····················································································································

  final func bind_selection (model : ReadOnlyArrayOf_BoardObject) {
    self.selectedArray_property.setDataProvider (model)
    self.bind_property_mSlavePadsShouldBeRouted ()
    self.bind_property_mX ()
    self.bind_property_mY ()
    self.bind_property_mRotation ()
    self.bind_property_mSide ()
    self.bind_property_mDisplayLegend ()
    self.bind_property_mNameIsVisibleInBoard ()
    self.bind_property_mXName ()
    self.bind_property_mYName ()
    self.bind_property_mNameFontSize ()
    self.bind_property_mNameRotation ()
    self.bind_property_mValueIsVisibleInBoard ()
    self.bind_property_mXValue ()
    self.bind_property_mYValue ()
    self.bind_property_mValueFontSize ()
    self.bind_property_mValueRotation ()
    self.bind_property_mComponentValue ()
    self.bind_property_mNamePrefix ()
    self.bind_property_mNameIndex ()
    self.bind_property_mXUnit ()
    self.bind_property_mYUnit ()
    self.bind_property_deviceName ()
    self.bind_property_signatureForERCChecking ()
    self.bind_property_packagePadDictionary ()
    self.bind_property_selectedPackageName ()
    self.bind_property_availablePackages ()
    self.bind_property_issues ()
    self.bind_property_componentIsPlacedInBoard ()
    self.bind_property_componentIsPlacedInBoardString ()
    self.bind_property_strokeBezierPath ()
    self.bind_property_pinPadAssignments ()
    self.bind_property_hasSlavePads ()
    self.bind_property_placementInSchematic ()
    self.bind_property_deviceSymbolDictionary ()
    self.bind_property_componentNameFontName ()
    self.bind_property_componentValueFontName ()
    self.bind_property_componentPadDictionary ()
    self.bind_property_padNetDictionary ()
    self.bind_property_componentName ()
    self.bind_property_selectionDisplay ()
    self.bind_property_unplacedSymbols ()
    self.bind_property_objectDisplay ()
  }

  //····················································································································
  //   UNBIND SELECTION
  //····················································································································

  final func unbind_selection () {
    self.selectedArray_property.setDataProvider (nil)
  //--- mSlavePadsShouldBeRouted
    self.mSlavePadsShouldBeRouted_property.mReadModelFunction = nil 
    self.mSlavePadsShouldBeRouted_property.mWriteModelFunction = nil 
    self.mSlavePadsShouldBeRouted_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mSlavePadsShouldBeRouted (self.mSlavePadsShouldBeRouted_property)
  //--- mX
    self.mX_property.mReadModelFunction = nil 
    self.mX_property.mWriteModelFunction = nil 
    self.mX_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mX (self.mX_property)
  //--- mY
    self.mY_property.mReadModelFunction = nil 
    self.mY_property.mWriteModelFunction = nil 
    self.mY_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mY (self.mY_property)
  //--- mRotation
    self.mRotation_property.mReadModelFunction = nil 
    self.mRotation_property.mWriteModelFunction = nil 
    self.mRotation_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mRotation (self.mRotation_property)
  //--- mSide
    self.mSide_property.mReadModelFunction = nil 
    self.mSide_property.mWriteModelFunction = nil 
    self.mSide_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mSide (self.mSide_property)
  //--- mDisplayLegend
    self.mDisplayLegend_property.mReadModelFunction = nil 
    self.mDisplayLegend_property.mWriteModelFunction = nil 
    self.mDisplayLegend_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mDisplayLegend (self.mDisplayLegend_property)
  //--- mNameIsVisibleInBoard
    self.mNameIsVisibleInBoard_property.mReadModelFunction = nil 
    self.mNameIsVisibleInBoard_property.mWriteModelFunction = nil 
    self.mNameIsVisibleInBoard_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mNameIsVisibleInBoard (self.mNameIsVisibleInBoard_property)
  //--- mXName
    self.mXName_property.mReadModelFunction = nil 
    self.mXName_property.mWriteModelFunction = nil 
    self.mXName_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mXName (self.mXName_property)
  //--- mYName
    self.mYName_property.mReadModelFunction = nil 
    self.mYName_property.mWriteModelFunction = nil 
    self.mYName_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mYName (self.mYName_property)
  //--- mNameFontSize
    self.mNameFontSize_property.mReadModelFunction = nil 
    self.mNameFontSize_property.mWriteModelFunction = nil 
    self.mNameFontSize_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mNameFontSize (self.mNameFontSize_property)
  //--- mNameRotation
    self.mNameRotation_property.mReadModelFunction = nil 
    self.mNameRotation_property.mWriteModelFunction = nil 
    self.mNameRotation_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mNameRotation (self.mNameRotation_property)
  //--- mValueIsVisibleInBoard
    self.mValueIsVisibleInBoard_property.mReadModelFunction = nil 
    self.mValueIsVisibleInBoard_property.mWriteModelFunction = nil 
    self.mValueIsVisibleInBoard_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mValueIsVisibleInBoard (self.mValueIsVisibleInBoard_property)
  //--- mXValue
    self.mXValue_property.mReadModelFunction = nil 
    self.mXValue_property.mWriteModelFunction = nil 
    self.mXValue_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mXValue (self.mXValue_property)
  //--- mYValue
    self.mYValue_property.mReadModelFunction = nil 
    self.mYValue_property.mWriteModelFunction = nil 
    self.mYValue_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mYValue (self.mYValue_property)
  //--- mValueFontSize
    self.mValueFontSize_property.mReadModelFunction = nil 
    self.mValueFontSize_property.mWriteModelFunction = nil 
    self.mValueFontSize_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mValueFontSize (self.mValueFontSize_property)
  //--- mValueRotation
    self.mValueRotation_property.mReadModelFunction = nil 
    self.mValueRotation_property.mWriteModelFunction = nil 
    self.mValueRotation_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mValueRotation (self.mValueRotation_property)
  //--- mComponentValue
    self.mComponentValue_property.mReadModelFunction = nil 
    self.mComponentValue_property.mWriteModelFunction = nil 
    self.mComponentValue_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mComponentValue (self.mComponentValue_property)
  //--- mNamePrefix
    self.mNamePrefix_property.mReadModelFunction = nil 
    self.mNamePrefix_property.mWriteModelFunction = nil 
    self.mNamePrefix_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mNamePrefix (self.mNamePrefix_property)
  //--- mNameIndex
    self.mNameIndex_property.mReadModelFunction = nil 
    self.mNameIndex_property.mWriteModelFunction = nil 
    self.mNameIndex_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mNameIndex (self.mNameIndex_property)
  //--- mXUnit
    self.mXUnit_property.mReadModelFunction = nil 
    self.mXUnit_property.mWriteModelFunction = nil 
    self.mXUnit_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mXUnit (self.mXUnit_property)
  //--- mYUnit
    self.mYUnit_property.mReadModelFunction = nil 
    self.mYUnit_property.mWriteModelFunction = nil 
    self.mYUnit_property.mValidateAndWriteModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_mYUnit (self.mYUnit_property)
  //--- deviceName
    self.deviceName_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_deviceName (self.deviceName_property)
  //--- signatureForERCChecking
    self.signatureForERCChecking_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_signatureForERCChecking (self.signatureForERCChecking_property)
  //--- packagePadDictionary
    self.packagePadDictionary_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_packagePadDictionary (self.packagePadDictionary_property)
  //--- selectedPackageName
    self.selectedPackageName_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_selectedPackageName (self.selectedPackageName_property)
  //--- availablePackages
    self.availablePackages_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_availablePackages (self.availablePackages_property)
  //--- issues
    self.issues_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_issues (self.issues_property)
  //--- componentIsPlacedInBoard
    self.componentIsPlacedInBoard_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_componentIsPlacedInBoard (self.componentIsPlacedInBoard_property)
  //--- componentIsPlacedInBoardString
    self.componentIsPlacedInBoardString_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_componentIsPlacedInBoardString (self.componentIsPlacedInBoardString_property)
  //--- strokeBezierPath
    self.strokeBezierPath_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_strokeBezierPath (self.strokeBezierPath_property)
  //--- pinPadAssignments
    self.pinPadAssignments_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_pinPadAssignments (self.pinPadAssignments_property)
  //--- hasSlavePads
    self.hasSlavePads_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_hasSlavePads (self.hasSlavePads_property)
  //--- placementInSchematic
    self.placementInSchematic_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_placementInSchematic (self.placementInSchematic_property)
  //--- deviceSymbolDictionary
    self.deviceSymbolDictionary_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_deviceSymbolDictionary (self.deviceSymbolDictionary_property)
  //--- componentNameFontName
    self.componentNameFontName_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_componentNameFontName (self.componentNameFontName_property)
  //--- componentValueFontName
    self.componentValueFontName_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_componentValueFontName (self.componentValueFontName_property)
  //--- componentPadDictionary
    self.componentPadDictionary_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_componentPadDictionary (self.componentPadDictionary_property)
  //--- padNetDictionary
    self.padNetDictionary_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_padNetDictionary (self.padNetDictionary_property)
  //--- componentName
    self.componentName_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_componentName (self.componentName_property)
  //--- selectionDisplay
    self.selectionDisplay_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_selectionDisplay (self.selectionDisplay_property)
  //--- unplacedSymbols
    self.unplacedSymbols_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_unplacedSymbols (self.unplacedSymbols_property)
  //--- objectDisplay
    self.objectDisplay_property.mReadModelFunction = nil 
    self.selectedArray_property.removeEBObserverOf_objectDisplay (self.objectDisplay_property)
  }

  //····················································································································
  //    Explorer
  //····················································································································

  private var mValueExplorer : NSButton?
  private var mExplorerWindow : NSWindow?

  //····················································································································

  final func addExplorer (name : String, y : inout CGFloat, view : NSView) {
    let font = NSFont.boldSystemFont (ofSize: NSFont.smallSystemFontSize)
    let tf = NSTextField (frame:secondColumn (y))
    tf.isEnabled = true
    tf.isEditable = false
    tf.stringValue = name
    tf.font = font
    view.addSubview (tf)
    let valueExplorer = NSButton (frame: thirdColumn (y))
    valueExplorer.font = font
    valueExplorer.title = explorerIndexString (ebObjectIndex) + " " + String (describing: type (of: self))
    valueExplorer.target = self
    valueExplorer.action = #selector(SelectionController_ProjectDocument_componentInBoardSelectionController.showObjectWindowFromExplorerButton(_:))
    view.addSubview (valueExplorer)
    self.mValueExplorer = valueExplorer
    y += EXPLORER_ROW_HEIGHT
  }

  //····················································································································

  func buildExplorerWindow () {
  //-------------------------------------------------- Create Window
    let r = NSRect (x: 20.0, y: 20.0, width: 10.0, height: 10.0)
    self.mExplorerWindow = NSWindow (contentRect: r, styleMask: [.titled, .closable], backing: .buffered, defer: true, screen: nil)
  //-------------------------------------------------- Adding properties
    let view = NSView (frame: r)
    var y : CGFloat = 0.0
    createEntryForPropertyNamed (
      "mSlavePadsShouldBeRouted",
      idx: self.mSlavePadsShouldBeRouted_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.mSlavePadsShouldBeRouted_property.mObserverExplorer,
      valueExplorer: &self.mSlavePadsShouldBeRouted_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "mX",
      idx: self.mX_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.mX_property.mObserverExplorer,
      valueExplorer: &self.mX_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "mY",
      idx: self.mY_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.mY_property.mObserverExplorer,
      valueExplorer: &self.mY_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "mRotation",
      idx: self.mRotation_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.mRotation_property.mObserverExplorer,
      valueExplorer: &self.mRotation_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "mSide",
      idx: self.mSide_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.mSide_property.mObserverExplorer,
      valueExplorer: &self.mSide_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "mDisplayLegend",
      idx: self.mDisplayLegend_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.mDisplayLegend_property.mObserverExplorer,
      valueExplorer: &self.mDisplayLegend_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "mNameIsVisibleInBoard",
      idx: self.mNameIsVisibleInBoard_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.mNameIsVisibleInBoard_property.mObserverExplorer,
      valueExplorer: &self.mNameIsVisibleInBoard_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "mXName",
      idx: self.mXName_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.mXName_property.mObserverExplorer,
      valueExplorer: &self.mXName_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "mYName",
      idx: self.mYName_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.mYName_property.mObserverExplorer,
      valueExplorer: &self.mYName_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "mNameFontSize",
      idx: self.mNameFontSize_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.mNameFontSize_property.mObserverExplorer,
      valueExplorer: &self.mNameFontSize_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "mNameRotation",
      idx: self.mNameRotation_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.mNameRotation_property.mObserverExplorer,
      valueExplorer: &self.mNameRotation_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "mValueIsVisibleInBoard",
      idx: self.mValueIsVisibleInBoard_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.mValueIsVisibleInBoard_property.mObserverExplorer,
      valueExplorer: &self.mValueIsVisibleInBoard_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "mXValue",
      idx: self.mXValue_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.mXValue_property.mObserverExplorer,
      valueExplorer: &self.mXValue_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "mYValue",
      idx: self.mYValue_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.mYValue_property.mObserverExplorer,
      valueExplorer: &self.mYValue_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "mValueFontSize",
      idx: self.mValueFontSize_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.mValueFontSize_property.mObserverExplorer,
      valueExplorer: &self.mValueFontSize_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "mValueRotation",
      idx: self.mValueRotation_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.mValueRotation_property.mObserverExplorer,
      valueExplorer: &self.mValueRotation_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "mComponentValue",
      idx: self.mComponentValue_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.mComponentValue_property.mObserverExplorer,
      valueExplorer: &self.mComponentValue_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "mNamePrefix",
      idx: self.mNamePrefix_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.mNamePrefix_property.mObserverExplorer,
      valueExplorer: &self.mNamePrefix_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "mNameIndex",
      idx: self.mNameIndex_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.mNameIndex_property.mObserverExplorer,
      valueExplorer: &self.mNameIndex_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "mXUnit",
      idx: self.mXUnit_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.mXUnit_property.mObserverExplorer,
      valueExplorer: &self.mXUnit_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "mYUnit",
      idx: self.mYUnit_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.mYUnit_property.mObserverExplorer,
      valueExplorer: &self.mYUnit_property.mValueExplorer
    )
  //-------------------------------------------------- Finish Window construction
  //--- Resize View
    let viewFrame = NSRect (x: 0.0, y: 0.0, width: EXPLORER_ROW_WIDTH, height: y)
    view.frame = viewFrame
  //--- Set content size
    self.mExplorerWindow?.setContentSize (NSSize (width: EXPLORER_ROW_WIDTH + 16.0, height: fmin (600.0, y)))
  //--- Set close button as 'remove window' button
    let closeButton : NSButton? = self.mExplorerWindow?.standardWindowButton (.closeButton)
    closeButton?.target = self
    closeButton?.action = #selector(SelectionController_ProjectDocument_componentInBoardSelectionController.deleteSelectionControllerWindowAction(_:))
  //--- Set window title
    let windowTitle = explorerIndexString (ebObjectIndex) + " " + String (describing: type (of: self))
    self.mExplorerWindow!.title = windowTitle
  //--- Add Scroll view
    let frame = NSRect (x: 0.0, y: 0.0, width: EXPLORER_ROW_WIDTH, height: y)
    let sw = NSScrollView (frame: frame)
    sw.hasVerticalScroller = true
    sw.documentView = view
    self.mExplorerWindow!.contentView = sw
  }

  //····················································································································
  //   showObjectWindowFromExplorerButton
  //····················································································································

  @objc func showObjectWindowFromExplorerButton (_ : Any) {
    if self.mExplorerWindow == nil {
      self.buildExplorerWindow ()
    }
    self.mExplorerWindow?.makeKeyAndOrderFront (nil)
  }

  //····················································································································
  //   deleteSelectionControllerWindowAction
  //····················································································································

  @objc func deleteSelectionControllerWindowAction (_ : Any) {
    self.clearObjectExplorer ()
  }

  //····················································································································
  //   clearObjectExplorer
  //····················································································································

  func clearObjectExplorer () {
    if let closeButton = self.mExplorerWindow?.standardWindowButton (.closeButton) {
      closeButton.target = nil
    }
    self.mExplorerWindow?.orderOut (nil)
    self.mExplorerWindow = nil
  }

  //····················································································································

  private final func bind_property_mSlavePadsShouldBeRouted () {
    self.selectedArray_property.addEBObserverOf_mSlavePadsShouldBeRouted (self.mSlavePadsShouldBeRouted_property)
    self.mSlavePadsShouldBeRouted_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mSlavePadsShouldBeRouted_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mSlavePadsShouldBeRouted_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mSlavePadsShouldBeRouted_property.setProp (inValue)
          }
        }
      }
    }
    self.mSlavePadsShouldBeRouted_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mSlavePadsShouldBeRouted_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mX () {
    self.selectedArray_property.addEBObserverOf_mX (self.mX_property)
    self.mX_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mX_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mX_property.mWriteModelFunction = { [weak self] (inValue : Int) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mX_property.setProp (inValue)
          }
        }
      }
    }
    self.mX_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mX_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mY () {
    self.selectedArray_property.addEBObserverOf_mY (self.mY_property)
    self.mY_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mY_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mY_property.mWriteModelFunction = { [weak self] (inValue : Int) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mY_property.setProp (inValue)
          }
        }
      }
    }
    self.mY_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mY_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mRotation () {
    self.selectedArray_property.addEBObserverOf_mRotation (self.mRotation_property)
    self.mRotation_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mRotation_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mRotation_property.mWriteModelFunction = { [weak self] (inValue : Int) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mRotation_property.setProp (inValue)
          }
        }
      }
    }
    self.mRotation_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mRotation_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mSide () {
    self.selectedArray_property.addEBObserverOf_mSide (self.mSide_property)
    self.mSide_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <ComponentSide> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mSide_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mSide_property.mWriteModelFunction = { [weak self] (inValue : ComponentSide) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mSide_property.setProp (inValue)
          }
        }
      }
    }
    self.mSide_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : ComponentSide, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mSide_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mDisplayLegend () {
    self.selectedArray_property.addEBObserverOf_mDisplayLegend (self.mDisplayLegend_property)
    self.mDisplayLegend_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mDisplayLegend_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mDisplayLegend_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mDisplayLegend_property.setProp (inValue)
          }
        }
      }
    }
    self.mDisplayLegend_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mDisplayLegend_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mNameIsVisibleInBoard () {
    self.selectedArray_property.addEBObserverOf_mNameIsVisibleInBoard (self.mNameIsVisibleInBoard_property)
    self.mNameIsVisibleInBoard_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mNameIsVisibleInBoard_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mNameIsVisibleInBoard_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mNameIsVisibleInBoard_property.setProp (inValue)
          }
        }
      }
    }
    self.mNameIsVisibleInBoard_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mNameIsVisibleInBoard_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mXName () {
    self.selectedArray_property.addEBObserverOf_mXName (self.mXName_property)
    self.mXName_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mXName_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mXName_property.mWriteModelFunction = { [weak self] (inValue : Int) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mXName_property.setProp (inValue)
          }
        }
      }
    }
    self.mXName_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mXName_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mYName () {
    self.selectedArray_property.addEBObserverOf_mYName (self.mYName_property)
    self.mYName_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mYName_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mYName_property.mWriteModelFunction = { [weak self] (inValue : Int) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mYName_property.setProp (inValue)
          }
        }
      }
    }
    self.mYName_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mYName_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mNameFontSize () {
    self.selectedArray_property.addEBObserverOf_mNameFontSize (self.mNameFontSize_property)
    self.mNameFontSize_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Double> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mNameFontSize_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mNameFontSize_property.mWriteModelFunction = { [weak self] (inValue : Double) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mNameFontSize_property.setProp (inValue)
          }
        }
      }
    }
    self.mNameFontSize_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Double, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mNameFontSize_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mNameRotation () {
    self.selectedArray_property.addEBObserverOf_mNameRotation (self.mNameRotation_property)
    self.mNameRotation_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mNameRotation_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mNameRotation_property.mWriteModelFunction = { [weak self] (inValue : Int) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mNameRotation_property.setProp (inValue)
          }
        }
      }
    }
    self.mNameRotation_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mNameRotation_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mValueIsVisibleInBoard () {
    self.selectedArray_property.addEBObserverOf_mValueIsVisibleInBoard (self.mValueIsVisibleInBoard_property)
    self.mValueIsVisibleInBoard_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mValueIsVisibleInBoard_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mValueIsVisibleInBoard_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mValueIsVisibleInBoard_property.setProp (inValue)
          }
        }
      }
    }
    self.mValueIsVisibleInBoard_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mValueIsVisibleInBoard_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mXValue () {
    self.selectedArray_property.addEBObserverOf_mXValue (self.mXValue_property)
    self.mXValue_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mXValue_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mXValue_property.mWriteModelFunction = { [weak self] (inValue : Int) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mXValue_property.setProp (inValue)
          }
        }
      }
    }
    self.mXValue_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mXValue_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mYValue () {
    self.selectedArray_property.addEBObserverOf_mYValue (self.mYValue_property)
    self.mYValue_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mYValue_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mYValue_property.mWriteModelFunction = { [weak self] (inValue : Int) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mYValue_property.setProp (inValue)
          }
        }
      }
    }
    self.mYValue_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mYValue_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mValueFontSize () {
    self.selectedArray_property.addEBObserverOf_mValueFontSize (self.mValueFontSize_property)
    self.mValueFontSize_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Double> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mValueFontSize_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mValueFontSize_property.mWriteModelFunction = { [weak self] (inValue : Double) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mValueFontSize_property.setProp (inValue)
          }
        }
      }
    }
    self.mValueFontSize_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Double, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mValueFontSize_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mValueRotation () {
    self.selectedArray_property.addEBObserverOf_mValueRotation (self.mValueRotation_property)
    self.mValueRotation_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mValueRotation_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mValueRotation_property.mWriteModelFunction = { [weak self] (inValue : Int) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mValueRotation_property.setProp (inValue)
          }
        }
      }
    }
    self.mValueRotation_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mValueRotation_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mComponentValue () {
    self.selectedArray_property.addEBObserverOf_mComponentValue (self.mComponentValue_property)
    self.mComponentValue_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <String> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mComponentValue_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mComponentValue_property.mWriteModelFunction = { [weak self] (inValue : String) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mComponentValue_property.setProp (inValue)
          }
        }
      }
    }
    self.mComponentValue_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : String, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mComponentValue_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mNamePrefix () {
    self.selectedArray_property.addEBObserverOf_mNamePrefix (self.mNamePrefix_property)
    self.mNamePrefix_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <String> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mNamePrefix_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mNamePrefix_property.mWriteModelFunction = { [weak self] (inValue : String) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mNamePrefix_property.setProp (inValue)
          }
        }
      }
    }
    self.mNamePrefix_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : String, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mNamePrefix_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mNameIndex () {
    self.selectedArray_property.addEBObserverOf_mNameIndex (self.mNameIndex_property)
    self.mNameIndex_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mNameIndex_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mNameIndex_property.mWriteModelFunction = { [weak self] (inValue : Int) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mNameIndex_property.setProp (inValue)
          }
        }
      }
    }
    self.mNameIndex_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mNameIndex_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mXUnit () {
    self.selectedArray_property.addEBObserverOf_mXUnit (self.mXUnit_property)
    self.mXUnit_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mXUnit_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mXUnit_property.mWriteModelFunction = { [weak self] (inValue : Int) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mXUnit_property.setProp (inValue)
          }
        }
      }
    }
    self.mXUnit_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mXUnit_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_mYUnit () {
    self.selectedArray_property.addEBObserverOf_mYUnit (self.mYUnit_property)
    self.mYUnit_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.mYUnit_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.mYUnit_property.mWriteModelFunction = { [weak self] (inValue : Int) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.mYUnit_property.setProp (inValue)
          }
        }
      }
    }
    self.mYUnit_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.mYUnit_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }
  //····················································································································

  private final func bind_property_deviceName () {
    self.selectedArray_property.addEBObserverOf_deviceName (self.deviceName_property)
    self.deviceName_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <String> ()
          var isMultipleSelection = false
          for object in v {
            switch object.deviceName_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_signatureForERCChecking () {
    self.selectedArray_property.addEBObserverOf_signatureForERCChecking (self.signatureForERCChecking_property)
    self.signatureForERCChecking_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <UInt32> ()
          var isMultipleSelection = false
          for object in v {
            switch object.signatureForERCChecking_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_packagePadDictionary () {
    self.selectedArray_property.addEBObserverOf_packagePadDictionary (self.packagePadDictionary_property)
    self.packagePadDictionary_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <PackageMasterPadDictionary> ()
          var isMultipleSelection = false
          for object in v {
            switch object.packagePadDictionary_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_selectedPackageName () {
    self.selectedArray_property.addEBObserverOf_selectedPackageName (self.selectedPackageName_property)
    self.selectedPackageName_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <String> ()
          var isMultipleSelection = false
          for object in v {
            switch object.selectedPackageName_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_availablePackages () {
    self.selectedArray_property.addEBObserverOf_availablePackages (self.availablePackages_property)
    self.availablePackages_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <StringArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.availablePackages_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_issues () {
    self.selectedArray_property.addEBObserverOf_issues (self.issues_property)
    self.issues_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <CanariIssueArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.issues_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_componentIsPlacedInBoard () {
    self.selectedArray_property.addEBObserverOf_componentIsPlacedInBoard (self.componentIsPlacedInBoard_property)
    self.componentIsPlacedInBoard_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.componentIsPlacedInBoard_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_componentIsPlacedInBoardString () {
    self.selectedArray_property.addEBObserverOf_componentIsPlacedInBoardString (self.componentIsPlacedInBoardString_property)
    self.componentIsPlacedInBoardString_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <String> ()
          var isMultipleSelection = false
          for object in v {
            switch object.componentIsPlacedInBoardString_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_strokeBezierPath () {
    self.selectedArray_property.addEBObserverOf_strokeBezierPath (self.strokeBezierPath_property)
    self.strokeBezierPath_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <EBBezierPath> ()
          var isMultipleSelection = false
          for object in v {
            switch object.strokeBezierPath_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_pinPadAssignments () {
    self.selectedArray_property.addEBObserverOf_pinPadAssignments (self.pinPadAssignments_property)
    self.pinPadAssignments_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <ThreeStringArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.pinPadAssignments_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_hasSlavePads () {
    self.selectedArray_property.addEBObserverOf_hasSlavePads (self.hasSlavePads_property)
    self.hasSlavePads_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.hasSlavePads_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_placementInSchematic () {
    self.selectedArray_property.addEBObserverOf_placementInSchematic (self.placementInSchematic_property)
    self.placementInSchematic_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <String> ()
          var isMultipleSelection = false
          for object in v {
            switch object.placementInSchematic_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_deviceSymbolDictionary () {
    self.selectedArray_property.addEBObserverOf_deviceSymbolDictionary (self.deviceSymbolDictionary_property)
    self.deviceSymbolDictionary_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <DeviceSymbolDictionary> ()
          var isMultipleSelection = false
          for object in v {
            switch object.deviceSymbolDictionary_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_componentNameFontName () {
    self.selectedArray_property.addEBObserverOf_componentNameFontName (self.componentNameFontName_property)
    self.componentNameFontName_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <String> ()
          var isMultipleSelection = false
          for object in v {
            switch object.componentNameFontName_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_componentValueFontName () {
    self.selectedArray_property.addEBObserverOf_componentValueFontName (self.componentValueFontName_property)
    self.componentValueFontName_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <String> ()
          var isMultipleSelection = false
          for object in v {
            switch object.componentValueFontName_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_componentPadDictionary () {
    self.selectedArray_property.addEBObserverOf_componentPadDictionary (self.componentPadDictionary_property)
    self.componentPadDictionary_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <ComponentPadDescriptorDictionary> ()
          var isMultipleSelection = false
          for object in v {
            switch object.componentPadDictionary_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_padNetDictionary () {
    self.selectedArray_property.addEBObserverOf_padNetDictionary (self.padNetDictionary_property)
    self.padNetDictionary_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <PadNetDictionary> ()
          var isMultipleSelection = false
          for object in v {
            switch object.padNetDictionary_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_componentName () {
    self.selectedArray_property.addEBObserverOf_componentName (self.componentName_property)
    self.componentName_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <String> ()
          var isMultipleSelection = false
          for object in v {
            switch object.componentName_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_selectionDisplay () {
    self.selectedArray_property.addEBObserverOf_selectionDisplay (self.selectionDisplay_property)
    self.selectionDisplay_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <EBShape> ()
          var isMultipleSelection = false
          for object in v {
            switch object.selectionDisplay_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_unplacedSymbols () {
    self.selectedArray_property.addEBObserverOf_unplacedSymbols (self.unplacedSymbols_property)
    self.unplacedSymbols_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <StringTagArray> ()
          var isMultipleSelection = false
          for object in v {
            switch object.unplacedSymbols_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }
  //····················································································································

  private final func bind_property_objectDisplay () {
    self.selectedArray_property.addEBObserverOf_objectDisplay (self.objectDisplay_property)
    self.objectDisplay_property.mReadModelFunction = { [weak self] in
      if let model = self?.selectedArray_property {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <EBShape> ()
          var isMultipleSelection = false
          for object in v {
            switch object.objectDisplay_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }


  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

