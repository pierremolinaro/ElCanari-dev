//----------------------------------------------------------------------------------------------------------------------
//  THIS FILE IS GENERATED BY EASY BINDINGS, DO NOT MODIFY IT
//----------------------------------------------------------------------------------------------------------------------

import Cocoa

//----------------------------------------------------------------------------------------------------------------------
//    Base Selection Controller ProjectDocument mDataSelection
//----------------------------------------------------------------------------------------------------------------------

final class SelectionController_ProjectDocument_mDataSelection : EBObject {

  //····················································································································
  //   Selection observable property: drawBoardLimits
  //····················································································································

  var drawBoardLimits_property = EBPropertyProxy_Bool ()

  var drawBoardLimits_property_selection : EBSelection <Bool> {
    return self.drawBoardLimits_property.selection
  }

  //····················································································································
  //   Selection observable property: drawComponentNamesBottomSide
  //····················································································································

  var drawComponentNamesBottomSide_property = EBPropertyProxy_Bool ()

  var drawComponentNamesBottomSide_property_selection : EBSelection <Bool> {
    return self.drawComponentNamesBottomSide_property.selection
  }

  //····················································································································
  //   Selection observable property: drawComponentNamesTopSide
  //····················································································································

  var drawComponentNamesTopSide_property = EBPropertyProxy_Bool ()

  var drawComponentNamesTopSide_property_selection : EBSelection <Bool> {
    return self.drawComponentNamesTopSide_property.selection
  }

  //····················································································································
  //   Selection observable property: drawComponentValuesBottomSide
  //····················································································································

  var drawComponentValuesBottomSide_property = EBPropertyProxy_Bool ()

  var drawComponentValuesBottomSide_property_selection : EBSelection <Bool> {
    return self.drawComponentValuesBottomSide_property.selection
  }

  //····················································································································
  //   Selection observable property: drawComponentValuesTopSide
  //····················································································································

  var drawComponentValuesTopSide_property = EBPropertyProxy_Bool ()

  var drawComponentValuesTopSide_property_selection : EBSelection <Bool> {
    return self.drawComponentValuesTopSide_property.selection
  }

  //····················································································································
  //   Selection observable property: drawInternalBoardLimits
  //····················································································································

  var drawInternalBoardLimits_property = EBPropertyProxy_Bool ()

  var drawInternalBoardLimits_property_selection : EBSelection <Bool> {
    return self.drawInternalBoardLimits_property.selection
  }

  //····················································································································
  //   Selection observable property: drawPackageLegendBottomSide
  //····················································································································

  var drawPackageLegendBottomSide_property = EBPropertyProxy_Bool ()

  var drawPackageLegendBottomSide_property_selection : EBSelection <Bool> {
    return self.drawPackageLegendBottomSide_property.selection
  }

  //····················································································································
  //   Selection observable property: drawPackageLegendTopSide
  //····················································································································

  var drawPackageLegendTopSide_property = EBPropertyProxy_Bool ()

  var drawPackageLegendTopSide_property_selection : EBSelection <Bool> {
    return self.drawPackageLegendTopSide_property.selection
  }

  //····················································································································
  //   Selection observable property: drawPadHolesInPDF
  //····················································································································

  var drawPadHolesInPDF_property = EBPropertyProxy_Bool ()

  var drawPadHolesInPDF_property_selection : EBSelection <Bool> {
    return self.drawPadHolesInPDF_property.selection
  }

  //····················································································································
  //   Selection observable property: drawPadsBottomSide
  //····················································································································

  var drawPadsBottomSide_property = EBPropertyProxy_Bool ()

  var drawPadsBottomSide_property_selection : EBSelection <Bool> {
    return self.drawPadsBottomSide_property.selection
  }

  //····················································································································
  //   Selection observable property: drawPadsTopSide
  //····················································································································

  var drawPadsTopSide_property = EBPropertyProxy_Bool ()

  var drawPadsTopSide_property_selection : EBSelection <Bool> {
    return self.drawPadsTopSide_property.selection
  }

  //····················································································································
  //   Selection observable property: drawTextsLayoutBottomSide
  //····················································································································

  var drawTextsLayoutBottomSide_property = EBPropertyProxy_Bool ()

  var drawTextsLayoutBottomSide_property_selection : EBSelection <Bool> {
    return self.drawTextsLayoutBottomSide_property.selection
  }

  //····················································································································
  //   Selection observable property: drawTextsLayoutTopSide
  //····················································································································

  var drawTextsLayoutTopSide_property = EBPropertyProxy_Bool ()

  var drawTextsLayoutTopSide_property_selection : EBSelection <Bool> {
    return self.drawTextsLayoutTopSide_property.selection
  }

  //····················································································································
  //   Selection observable property: drawTextsLegendBottomSide
  //····················································································································

  var drawTextsLegendBottomSide_property = EBPropertyProxy_Bool ()

  var drawTextsLegendBottomSide_property_selection : EBSelection <Bool> {
    return self.drawTextsLegendBottomSide_property.selection
  }

  //····················································································································
  //   Selection observable property: drawTextsLegendTopSide
  //····················································································································

  var drawTextsLegendTopSide_property = EBPropertyProxy_Bool ()

  var drawTextsLegendTopSide_property_selection : EBSelection <Bool> {
    return self.drawTextsLegendTopSide_property.selection
  }

  //····················································································································
  //   Selection observable property: drawTracksBottomSide
  //····················································································································

  var drawTracksBottomSide_property = EBPropertyProxy_Bool ()

  var drawTracksBottomSide_property_selection : EBSelection <Bool> {
    return self.drawTracksBottomSide_property.selection
  }

  //····················································································································
  //   Selection observable property: drawTracksTopSide
  //····················································································································

  var drawTracksTopSide_property = EBPropertyProxy_Bool ()

  var drawTracksTopSide_property_selection : EBSelection <Bool> {
    return self.drawTracksTopSide_property.selection
  }

  //····················································································································
  //   Selection observable property: drawVias
  //····················································································································

  var drawVias_property = EBPropertyProxy_Bool ()

  var drawVias_property_selection : EBSelection <Bool> {
    return self.drawVias_property.selection
  }

  //····················································································································
  //   Selection observable property: fileExtension
  //····················································································································

  var fileExtension_property = EBPropertyProxy_String ()

  var fileExtension_property_selection : EBSelection <String> {
    return self.fileExtension_property.selection
  }

  //····················································································································
  //   Selection observable property: horizontalMirror
  //····················································································································

  var horizontalMirror_property = EBPropertyProxy_Bool ()

  var horizontalMirror_property_selection : EBSelection <Bool> {
    return self.horizontalMirror_property.selection
  }

  //····················································································································
  //   Selection observable property: measurementUnitForPadHoleInPDF
  //····················································································································

  var measurementUnitForPadHoleInPDF_property = EBPropertyProxy_Int ()

  var measurementUnitForPadHoleInPDF_property_selection : EBSelection <Int> {
    return self.measurementUnitForPadHoleInPDF_property.selection
  }

  //····················································································································
  //   Selection observable property: name
  //····················································································································

  var name_property = EBPropertyProxy_String ()

  var name_property_selection : EBSelection <String> {
    return self.name_property.selection
  }

  //····················································································································
  //   Selection observable property: padHoleDiameterInPDF
  //····················································································································

  var padHoleDiameterInPDF_property = EBPropertyProxy_Int ()

  var padHoleDiameterInPDF_property_selection : EBSelection <Int> {
    return self.padHoleDiameterInPDF_property.selection
  }

  //····················································································································
  //   BIND SELECTION
  //····················································································································

  private var mModel : ReadOnlyArrayOf_ArtworkFileGenerationParameters? = nil

  //····················································································································

  func bind_selection (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    self.mModel = model
    self.bind_property_drawBoardLimits (model: model)
    self.bind_property_drawComponentNamesBottomSide (model: model)
    self.bind_property_drawComponentNamesTopSide (model: model)
    self.bind_property_drawComponentValuesBottomSide (model: model)
    self.bind_property_drawComponentValuesTopSide (model: model)
    self.bind_property_drawInternalBoardLimits (model: model)
    self.bind_property_drawPackageLegendBottomSide (model: model)
    self.bind_property_drawPackageLegendTopSide (model: model)
    self.bind_property_drawPadHolesInPDF (model: model)
    self.bind_property_drawPadsBottomSide (model: model)
    self.bind_property_drawPadsTopSide (model: model)
    self.bind_property_drawTextsLayoutBottomSide (model: model)
    self.bind_property_drawTextsLayoutTopSide (model: model)
    self.bind_property_drawTextsLegendBottomSide (model: model)
    self.bind_property_drawTextsLegendTopSide (model: model)
    self.bind_property_drawTracksBottomSide (model: model)
    self.bind_property_drawTracksTopSide (model: model)
    self.bind_property_drawVias (model: model)
    self.bind_property_fileExtension (model: model)
    self.bind_property_horizontalMirror (model: model)
    self.bind_property_measurementUnitForPadHoleInPDF (model: model)
    self.bind_property_name (model: model)
    self.bind_property_padHoleDiameterInPDF (model: model)
  }

  //····················································································································
  //   UNBIND SELECTION
  //····················································································································

  func unbind_selection () {
  //--- drawBoardLimits
    self.drawBoardLimits_property.mReadModelFunction = nil 
    self.drawBoardLimits_property.mWriteModelFunction = nil 
    self.drawBoardLimits_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_drawBoardLimits (self.drawBoardLimits_property)
  //--- drawComponentNamesBottomSide
    self.drawComponentNamesBottomSide_property.mReadModelFunction = nil 
    self.drawComponentNamesBottomSide_property.mWriteModelFunction = nil 
    self.drawComponentNamesBottomSide_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_drawComponentNamesBottomSide (self.drawComponentNamesBottomSide_property)
  //--- drawComponentNamesTopSide
    self.drawComponentNamesTopSide_property.mReadModelFunction = nil 
    self.drawComponentNamesTopSide_property.mWriteModelFunction = nil 
    self.drawComponentNamesTopSide_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_drawComponentNamesTopSide (self.drawComponentNamesTopSide_property)
  //--- drawComponentValuesBottomSide
    self.drawComponentValuesBottomSide_property.mReadModelFunction = nil 
    self.drawComponentValuesBottomSide_property.mWriteModelFunction = nil 
    self.drawComponentValuesBottomSide_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_drawComponentValuesBottomSide (self.drawComponentValuesBottomSide_property)
  //--- drawComponentValuesTopSide
    self.drawComponentValuesTopSide_property.mReadModelFunction = nil 
    self.drawComponentValuesTopSide_property.mWriteModelFunction = nil 
    self.drawComponentValuesTopSide_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_drawComponentValuesTopSide (self.drawComponentValuesTopSide_property)
  //--- drawInternalBoardLimits
    self.drawInternalBoardLimits_property.mReadModelFunction = nil 
    self.drawInternalBoardLimits_property.mWriteModelFunction = nil 
    self.drawInternalBoardLimits_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_drawInternalBoardLimits (self.drawInternalBoardLimits_property)
  //--- drawPackageLegendBottomSide
    self.drawPackageLegendBottomSide_property.mReadModelFunction = nil 
    self.drawPackageLegendBottomSide_property.mWriteModelFunction = nil 
    self.drawPackageLegendBottomSide_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_drawPackageLegendBottomSide (self.drawPackageLegendBottomSide_property)
  //--- drawPackageLegendTopSide
    self.drawPackageLegendTopSide_property.mReadModelFunction = nil 
    self.drawPackageLegendTopSide_property.mWriteModelFunction = nil 
    self.drawPackageLegendTopSide_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_drawPackageLegendTopSide (self.drawPackageLegendTopSide_property)
  //--- drawPadHolesInPDF
    self.drawPadHolesInPDF_property.mReadModelFunction = nil 
    self.drawPadHolesInPDF_property.mWriteModelFunction = nil 
    self.drawPadHolesInPDF_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_drawPadHolesInPDF (self.drawPadHolesInPDF_property)
  //--- drawPadsBottomSide
    self.drawPadsBottomSide_property.mReadModelFunction = nil 
    self.drawPadsBottomSide_property.mWriteModelFunction = nil 
    self.drawPadsBottomSide_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_drawPadsBottomSide (self.drawPadsBottomSide_property)
  //--- drawPadsTopSide
    self.drawPadsTopSide_property.mReadModelFunction = nil 
    self.drawPadsTopSide_property.mWriteModelFunction = nil 
    self.drawPadsTopSide_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_drawPadsTopSide (self.drawPadsTopSide_property)
  //--- drawTextsLayoutBottomSide
    self.drawTextsLayoutBottomSide_property.mReadModelFunction = nil 
    self.drawTextsLayoutBottomSide_property.mWriteModelFunction = nil 
    self.drawTextsLayoutBottomSide_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_drawTextsLayoutBottomSide (self.drawTextsLayoutBottomSide_property)
  //--- drawTextsLayoutTopSide
    self.drawTextsLayoutTopSide_property.mReadModelFunction = nil 
    self.drawTextsLayoutTopSide_property.mWriteModelFunction = nil 
    self.drawTextsLayoutTopSide_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_drawTextsLayoutTopSide (self.drawTextsLayoutTopSide_property)
  //--- drawTextsLegendBottomSide
    self.drawTextsLegendBottomSide_property.mReadModelFunction = nil 
    self.drawTextsLegendBottomSide_property.mWriteModelFunction = nil 
    self.drawTextsLegendBottomSide_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_drawTextsLegendBottomSide (self.drawTextsLegendBottomSide_property)
  //--- drawTextsLegendTopSide
    self.drawTextsLegendTopSide_property.mReadModelFunction = nil 
    self.drawTextsLegendTopSide_property.mWriteModelFunction = nil 
    self.drawTextsLegendTopSide_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_drawTextsLegendTopSide (self.drawTextsLegendTopSide_property)
  //--- drawTracksBottomSide
    self.drawTracksBottomSide_property.mReadModelFunction = nil 
    self.drawTracksBottomSide_property.mWriteModelFunction = nil 
    self.drawTracksBottomSide_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_drawTracksBottomSide (self.drawTracksBottomSide_property)
  //--- drawTracksTopSide
    self.drawTracksTopSide_property.mReadModelFunction = nil 
    self.drawTracksTopSide_property.mWriteModelFunction = nil 
    self.drawTracksTopSide_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_drawTracksTopSide (self.drawTracksTopSide_property)
  //--- drawVias
    self.drawVias_property.mReadModelFunction = nil 
    self.drawVias_property.mWriteModelFunction = nil 
    self.drawVias_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_drawVias (self.drawVias_property)
  //--- fileExtension
    self.fileExtension_property.mReadModelFunction = nil 
    self.fileExtension_property.mWriteModelFunction = nil 
    self.fileExtension_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_fileExtension (self.fileExtension_property)
  //--- horizontalMirror
    self.horizontalMirror_property.mReadModelFunction = nil 
    self.horizontalMirror_property.mWriteModelFunction = nil 
    self.horizontalMirror_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_horizontalMirror (self.horizontalMirror_property)
  //--- measurementUnitForPadHoleInPDF
    self.measurementUnitForPadHoleInPDF_property.mReadModelFunction = nil 
    self.measurementUnitForPadHoleInPDF_property.mWriteModelFunction = nil 
    self.measurementUnitForPadHoleInPDF_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_measurementUnitForPadHoleInPDF (self.measurementUnitForPadHoleInPDF_property)
  //--- name
    self.name_property.mReadModelFunction = nil 
    self.name_property.mWriteModelFunction = nil 
    self.name_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_name (self.name_property)
  //--- padHoleDiameterInPDF
    self.padHoleDiameterInPDF_property.mReadModelFunction = nil 
    self.padHoleDiameterInPDF_property.mWriteModelFunction = nil 
    self.padHoleDiameterInPDF_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_padHoleDiameterInPDF (self.padHoleDiameterInPDF_property)
  //---
    self.mModel = nil    
  }

  //····················································································································
  //    Explorer
  //····················································································································

  private var mValueExplorer : NSButton?
  private var mExplorerWindow : NSWindow?

  //····················································································································

  final func addExplorer (name : String, y : inout CGFloat, view : NSView) {
    let font = NSFont.boldSystemFont (ofSize: NSFont.smallSystemFontSize)
    let tf = NSTextField (frame:secondColumn (y))
    tf.isEnabled = true
    tf.isEditable = false
    tf.stringValue = name
    tf.font = font
    view.addSubview (tf)
    let valueExplorer = NSButton (frame:thirdColumn (y))
    valueExplorer.font = font
    valueExplorer.title = explorerIndexString (ebObjectIndex) + " " + className
    valueExplorer.target = self
    valueExplorer.action = #selector(SelectionController_ProjectDocument_mDataSelection.showObjectWindowFromExplorerButton(_:))
    view.addSubview (valueExplorer)
    mValueExplorer = valueExplorer
    y += EXPLORER_ROW_HEIGHT
  }
  
  //····················································································································

  func buildExplorerWindow () {
  //-------------------------------------------------- Create Window
    let r = NSRect (x:20.0, y:20.0, width:10.0, height:10.0)
    mExplorerWindow = NSWindow (contentRect: r, styleMask: [.titled, .closable], backing: .buffered, defer: true, screen: nil)
  //-------------------------------------------------- Adding properties
    let view = NSView (frame:r)
    var y : CGFloat = 0.0
    createEntryForPropertyNamed (
      "drawBoardLimits",
      idx: self.drawBoardLimits_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.drawBoardLimits_property.mObserverExplorer,
      valueExplorer: &self.drawBoardLimits_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawComponentNamesBottomSide",
      idx: self.drawComponentNamesBottomSide_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.drawComponentNamesBottomSide_property.mObserverExplorer,
      valueExplorer: &self.drawComponentNamesBottomSide_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawComponentNamesTopSide",
      idx: self.drawComponentNamesTopSide_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.drawComponentNamesTopSide_property.mObserverExplorer,
      valueExplorer: &self.drawComponentNamesTopSide_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawComponentValuesBottomSide",
      idx: self.drawComponentValuesBottomSide_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.drawComponentValuesBottomSide_property.mObserverExplorer,
      valueExplorer: &self.drawComponentValuesBottomSide_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawComponentValuesTopSide",
      idx: self.drawComponentValuesTopSide_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.drawComponentValuesTopSide_property.mObserverExplorer,
      valueExplorer: &self.drawComponentValuesTopSide_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawInternalBoardLimits",
      idx: self.drawInternalBoardLimits_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.drawInternalBoardLimits_property.mObserverExplorer,
      valueExplorer: &self.drawInternalBoardLimits_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawPackageLegendBottomSide",
      idx: self.drawPackageLegendBottomSide_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.drawPackageLegendBottomSide_property.mObserverExplorer,
      valueExplorer: &self.drawPackageLegendBottomSide_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawPackageLegendTopSide",
      idx: self.drawPackageLegendTopSide_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.drawPackageLegendTopSide_property.mObserverExplorer,
      valueExplorer: &self.drawPackageLegendTopSide_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawPadHolesInPDF",
      idx: self.drawPadHolesInPDF_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.drawPadHolesInPDF_property.mObserverExplorer,
      valueExplorer: &self.drawPadHolesInPDF_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawPadsBottomSide",
      idx: self.drawPadsBottomSide_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.drawPadsBottomSide_property.mObserverExplorer,
      valueExplorer: &self.drawPadsBottomSide_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawPadsTopSide",
      idx: self.drawPadsTopSide_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.drawPadsTopSide_property.mObserverExplorer,
      valueExplorer: &self.drawPadsTopSide_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawTextsLayoutBottomSide",
      idx: self.drawTextsLayoutBottomSide_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.drawTextsLayoutBottomSide_property.mObserverExplorer,
      valueExplorer: &self.drawTextsLayoutBottomSide_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawTextsLayoutTopSide",
      idx: self.drawTextsLayoutTopSide_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.drawTextsLayoutTopSide_property.mObserverExplorer,
      valueExplorer: &self.drawTextsLayoutTopSide_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawTextsLegendBottomSide",
      idx: self.drawTextsLegendBottomSide_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.drawTextsLegendBottomSide_property.mObserverExplorer,
      valueExplorer: &self.drawTextsLegendBottomSide_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawTextsLegendTopSide",
      idx: self.drawTextsLegendTopSide_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.drawTextsLegendTopSide_property.mObserverExplorer,
      valueExplorer: &self.drawTextsLegendTopSide_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawTracksBottomSide",
      idx: self.drawTracksBottomSide_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.drawTracksBottomSide_property.mObserverExplorer,
      valueExplorer: &self.drawTracksBottomSide_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawTracksTopSide",
      idx: self.drawTracksTopSide_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.drawTracksTopSide_property.mObserverExplorer,
      valueExplorer: &self.drawTracksTopSide_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "drawVias",
      idx: self.drawVias_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.drawVias_property.mObserverExplorer,
      valueExplorer: &self.drawVias_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "fileExtension",
      idx: self.fileExtension_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.fileExtension_property.mObserverExplorer,
      valueExplorer: &self.fileExtension_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "horizontalMirror",
      idx: self.horizontalMirror_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.horizontalMirror_property.mObserverExplorer,
      valueExplorer: &self.horizontalMirror_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "measurementUnitForPadHoleInPDF",
      idx: self.measurementUnitForPadHoleInPDF_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.measurementUnitForPadHoleInPDF_property.mObserverExplorer,
      valueExplorer: &self.measurementUnitForPadHoleInPDF_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "name",
      idx: self.name_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.name_property.mObserverExplorer,
      valueExplorer: &self.name_property.mValueExplorer
    )
    createEntryForPropertyNamed (
      "padHoleDiameterInPDF",
      idx: self.padHoleDiameterInPDF_property.ebObjectIndex,
      y: &y,
      view: view,
      observerExplorer: &self.padHoleDiameterInPDF_property.mObserverExplorer,
      valueExplorer: &self.padHoleDiameterInPDF_property.mValueExplorer
    )
  //-------------------------------------------------- Finish Window construction
  //--- Resize View
    let viewFrame = NSRect (x:0.0, y:0.0, width:EXPLORER_ROW_WIDTH, height:y)
    view.frame = viewFrame
  //--- Set content size
    mExplorerWindow?.setContentSize (NSSize (width:EXPLORER_ROW_WIDTH + 16.0, height:fmin (600.0, y)))
  //--- Set close button as 'remove window' button
    let closeButton : NSButton? = mExplorerWindow?.standardWindowButton (.closeButton)
    closeButton?.target = self
    closeButton?.action = #selector(SelectionController_ProjectDocument_mDataSelection.deleteSelectionControllerWindowAction(_:))
  //--- Set window title
    let windowTitle = explorerIndexString (ebObjectIndex) + " " + className
    mExplorerWindow!.title = windowTitle
  //--- Add Scroll view
    let frame = NSRect (x:0.0, y:0.0, width:EXPLORER_ROW_WIDTH, height:y)
    let sw = NSScrollView (frame:frame)
    sw.hasVerticalScroller = true
    sw.documentView = view
    mExplorerWindow!.contentView = sw
  }

  //····················································································································
  //   showObjectWindowFromExplorerButton
  //····················································································································

  @objc func showObjectWindowFromExplorerButton (_ : Any) {
    if mExplorerWindow == nil {
      buildExplorerWindow ()
    }
    mExplorerWindow?.makeKeyAndOrderFront(nil)
  }
  
  //····················································································································
  //   deleteSelectionControllerWindowAction
  //····················································································································

  @objc func deleteSelectionControllerWindowAction (_ : Any) {
    clearObjectExplorer ()
  }

  //····················································································································
  //   clearObjectExplorer
  //····················································································································

  func clearObjectExplorer () {
    let closeButton = mExplorerWindow?.standardWindowButton (.closeButton)
    closeButton!.target = nil
    mExplorerWindow?.orderOut (nil)
    mExplorerWindow = nil
  }

  //···················································································································*

  private final func bind_property_drawBoardLimits (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawBoardLimits (self.drawBoardLimits_property)
    self.drawBoardLimits_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawBoardLimits_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawBoardLimits_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawBoardLimits_property.setProp (inValue)
          }
        }
      }
    }
    self.drawBoardLimits_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawBoardLimits_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawComponentNamesBottomSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawComponentNamesBottomSide (self.drawComponentNamesBottomSide_property)
    self.drawComponentNamesBottomSide_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawComponentNamesBottomSide_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawComponentNamesBottomSide_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawComponentNamesBottomSide_property.setProp (inValue)
          }
        }
      }
    }
    self.drawComponentNamesBottomSide_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawComponentNamesBottomSide_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawComponentNamesTopSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawComponentNamesTopSide (self.drawComponentNamesTopSide_property)
    self.drawComponentNamesTopSide_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawComponentNamesTopSide_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawComponentNamesTopSide_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawComponentNamesTopSide_property.setProp (inValue)
          }
        }
      }
    }
    self.drawComponentNamesTopSide_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawComponentNamesTopSide_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawComponentValuesBottomSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawComponentValuesBottomSide (self.drawComponentValuesBottomSide_property)
    self.drawComponentValuesBottomSide_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawComponentValuesBottomSide_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawComponentValuesBottomSide_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawComponentValuesBottomSide_property.setProp (inValue)
          }
        }
      }
    }
    self.drawComponentValuesBottomSide_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawComponentValuesBottomSide_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawComponentValuesTopSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawComponentValuesTopSide (self.drawComponentValuesTopSide_property)
    self.drawComponentValuesTopSide_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawComponentValuesTopSide_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawComponentValuesTopSide_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawComponentValuesTopSide_property.setProp (inValue)
          }
        }
      }
    }
    self.drawComponentValuesTopSide_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawComponentValuesTopSide_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawInternalBoardLimits (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawInternalBoardLimits (self.drawInternalBoardLimits_property)
    self.drawInternalBoardLimits_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawInternalBoardLimits_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawInternalBoardLimits_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawInternalBoardLimits_property.setProp (inValue)
          }
        }
      }
    }
    self.drawInternalBoardLimits_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawInternalBoardLimits_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawPackageLegendBottomSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawPackageLegendBottomSide (self.drawPackageLegendBottomSide_property)
    self.drawPackageLegendBottomSide_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawPackageLegendBottomSide_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawPackageLegendBottomSide_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawPackageLegendBottomSide_property.setProp (inValue)
          }
        }
      }
    }
    self.drawPackageLegendBottomSide_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawPackageLegendBottomSide_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawPackageLegendTopSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawPackageLegendTopSide (self.drawPackageLegendTopSide_property)
    self.drawPackageLegendTopSide_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawPackageLegendTopSide_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawPackageLegendTopSide_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawPackageLegendTopSide_property.setProp (inValue)
          }
        }
      }
    }
    self.drawPackageLegendTopSide_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawPackageLegendTopSide_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawPadHolesInPDF (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawPadHolesInPDF (self.drawPadHolesInPDF_property)
    self.drawPadHolesInPDF_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawPadHolesInPDF_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawPadHolesInPDF_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawPadHolesInPDF_property.setProp (inValue)
          }
        }
      }
    }
    self.drawPadHolesInPDF_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawPadHolesInPDF_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawPadsBottomSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawPadsBottomSide (self.drawPadsBottomSide_property)
    self.drawPadsBottomSide_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawPadsBottomSide_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawPadsBottomSide_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawPadsBottomSide_property.setProp (inValue)
          }
        }
      }
    }
    self.drawPadsBottomSide_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawPadsBottomSide_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawPadsTopSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawPadsTopSide (self.drawPadsTopSide_property)
    self.drawPadsTopSide_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawPadsTopSide_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawPadsTopSide_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawPadsTopSide_property.setProp (inValue)
          }
        }
      }
    }
    self.drawPadsTopSide_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawPadsTopSide_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawTextsLayoutBottomSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawTextsLayoutBottomSide (self.drawTextsLayoutBottomSide_property)
    self.drawTextsLayoutBottomSide_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawTextsLayoutBottomSide_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawTextsLayoutBottomSide_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawTextsLayoutBottomSide_property.setProp (inValue)
          }
        }
      }
    }
    self.drawTextsLayoutBottomSide_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawTextsLayoutBottomSide_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawTextsLayoutTopSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawTextsLayoutTopSide (self.drawTextsLayoutTopSide_property)
    self.drawTextsLayoutTopSide_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawTextsLayoutTopSide_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawTextsLayoutTopSide_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawTextsLayoutTopSide_property.setProp (inValue)
          }
        }
      }
    }
    self.drawTextsLayoutTopSide_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawTextsLayoutTopSide_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawTextsLegendBottomSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawTextsLegendBottomSide (self.drawTextsLegendBottomSide_property)
    self.drawTextsLegendBottomSide_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawTextsLegendBottomSide_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawTextsLegendBottomSide_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawTextsLegendBottomSide_property.setProp (inValue)
          }
        }
      }
    }
    self.drawTextsLegendBottomSide_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawTextsLegendBottomSide_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawTextsLegendTopSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawTextsLegendTopSide (self.drawTextsLegendTopSide_property)
    self.drawTextsLegendTopSide_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawTextsLegendTopSide_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawTextsLegendTopSide_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawTextsLegendTopSide_property.setProp (inValue)
          }
        }
      }
    }
    self.drawTextsLegendTopSide_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawTextsLegendTopSide_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawTracksBottomSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawTracksBottomSide (self.drawTracksBottomSide_property)
    self.drawTracksBottomSide_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawTracksBottomSide_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawTracksBottomSide_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawTracksBottomSide_property.setProp (inValue)
          }
        }
      }
    }
    self.drawTracksBottomSide_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawTracksBottomSide_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawTracksTopSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawTracksTopSide (self.drawTracksTopSide_property)
    self.drawTracksTopSide_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawTracksTopSide_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawTracksTopSide_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawTracksTopSide_property.setProp (inValue)
          }
        }
      }
    }
    self.drawTracksTopSide_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawTracksTopSide_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawVias (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawVias (self.drawVias_property)
    self.drawVias_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawVias_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawVias_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawVias_property.setProp (inValue)
          }
        }
      }
    }
    self.drawVias_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawVias_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_fileExtension (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_fileExtension (self.fileExtension_property)
    self.fileExtension_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <String> ()
          var isMultipleSelection = false
          for object in v {
            switch object.fileExtension_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.fileExtension_property.mWriteModelFunction = { [weak self] (inValue : String) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.fileExtension_property.setProp (inValue)
          }
        }
      }
    }
    self.fileExtension_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : String, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.fileExtension_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_horizontalMirror (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_horizontalMirror (self.horizontalMirror_property)
    self.horizontalMirror_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.horizontalMirror_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.horizontalMirror_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.horizontalMirror_property.setProp (inValue)
          }
        }
      }
    }
    self.horizontalMirror_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.horizontalMirror_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_measurementUnitForPadHoleInPDF (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_measurementUnitForPadHoleInPDF (self.measurementUnitForPadHoleInPDF_property)
    self.measurementUnitForPadHoleInPDF_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.measurementUnitForPadHoleInPDF_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.measurementUnitForPadHoleInPDF_property.mWriteModelFunction = { [weak self] (inValue : Int) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.measurementUnitForPadHoleInPDF_property.setProp (inValue)
          }
        }
      }
    }
    self.measurementUnitForPadHoleInPDF_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.measurementUnitForPadHoleInPDF_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_name (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_name (self.name_property)
    self.name_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <String> ()
          var isMultipleSelection = false
          for object in v {
            switch object.name_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.name_property.mWriteModelFunction = { [weak self] (inValue : String) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.name_property.setProp (inValue)
          }
        }
      }
    }
    self.name_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : String, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.name_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_padHoleDiameterInPDF (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_padHoleDiameterInPDF (self.padHoleDiameterInPDF_property)
    self.padHoleDiameterInPDF_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.padHoleDiameterInPDF_property_selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.padHoleDiameterInPDF_property.mWriteModelFunction = { [weak self] (inValue : Int) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.padHoleDiameterInPDF_property.setProp (inValue)
          }
        }
      }
    }
    self.padHoleDiameterInPDF_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.padHoleDiameterInPDF_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }



  //····················································································································

}

//----------------------------------------------------------------------------------------------------------------------

