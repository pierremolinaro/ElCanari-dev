//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  THIS FILE IS GENERATED BY EASY BINDINGS, DO NOT MODIFY IT
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

import Cocoa

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    Base Selection Controller ProjectDocument mDataSelection
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

final class SelectionController_ProjectDocument_mDataSelection : EBSwiftBaseObject {

  //····················································································································
  //   Selection observable property: drawBoardLimits
  //····················································································································

  var drawBoardLimits_property = EBPropertyProxy_Bool ()

  //····················································································································
  //   Selection observable property: drawComponentNamesBottomSide
  //····················································································································

  var drawComponentNamesBottomSide_property = EBPropertyProxy_Bool ()

  //····················································································································
  //   Selection observable property: drawComponentNamesTopSide
  //····················································································································

  var drawComponentNamesTopSide_property = EBPropertyProxy_Bool ()

  //····················································································································
  //   Selection observable property: drawComponentValuesBottomSide
  //····················································································································

  var drawComponentValuesBottomSide_property = EBPropertyProxy_Bool ()

  //····················································································································
  //   Selection observable property: drawComponentValuesTopSide
  //····················································································································

  var drawComponentValuesTopSide_property = EBPropertyProxy_Bool ()

  //····················································································································
  //   Selection observable property: drawInternalBoardLimits
  //····················································································································

  var drawInternalBoardLimits_property = EBPropertyProxy_Bool ()

  //····················································································································
  //   Selection observable property: drawPackageLegendBottomSide
  //····················································································································

  var drawPackageLegendBottomSide_property = EBPropertyProxy_Bool ()

  //····················································································································
  //   Selection observable property: drawPackageLegendTopSide
  //····················································································································

  var drawPackageLegendTopSide_property = EBPropertyProxy_Bool ()

  //····················································································································
  //   Selection observable property: drawPadHolesInPDF
  //····················································································································

  var drawPadHolesInPDF_property = EBPropertyProxy_Bool ()

  //····················································································································
  //   Selection observable property: drawPadsBottomSide
  //····················································································································

  var drawPadsBottomSide_property = EBPropertyProxy_Bool ()

  //····················································································································
  //   Selection observable property: drawPadsTopSide
  //····················································································································

  var drawPadsTopSide_property = EBPropertyProxy_Bool ()

  //····················································································································
  //   Selection observable property: drawTextsLayoutBottomSide
  //····················································································································

  var drawTextsLayoutBottomSide_property = EBPropertyProxy_Bool ()

  //····················································································································
  //   Selection observable property: drawTextsLayoutTopSide
  //····················································································································

  var drawTextsLayoutTopSide_property = EBPropertyProxy_Bool ()

  //····················································································································
  //   Selection observable property: drawTextsLegendBottomSide
  //····················································································································

  var drawTextsLegendBottomSide_property = EBPropertyProxy_Bool ()

  //····················································································································
  //   Selection observable property: drawTextsLegendTopSide
  //····················································································································

  var drawTextsLegendTopSide_property = EBPropertyProxy_Bool ()

  //····················································································································
  //   Selection observable property: drawTracksBottomSide
  //····················································································································

  var drawTracksBottomSide_property = EBPropertyProxy_Bool ()

  //····················································································································
  //   Selection observable property: drawTracksInner1Layer
  //····················································································································

  var drawTracksInner1Layer_property = EBPropertyProxy_Bool ()

  //····················································································································
  //   Selection observable property: drawTracksInner2Layer
  //····················································································································

  var drawTracksInner2Layer_property = EBPropertyProxy_Bool ()

  //····················································································································
  //   Selection observable property: drawTracksInner3Layer
  //····················································································································

  var drawTracksInner3Layer_property = EBPropertyProxy_Bool ()

  //····················································································································
  //   Selection observable property: drawTracksInner4Layer
  //····················································································································

  var drawTracksInner4Layer_property = EBPropertyProxy_Bool ()

  //····················································································································
  //   Selection observable property: drawTracksTopSide
  //····················································································································

  var drawTracksTopSide_property = EBPropertyProxy_Bool ()

  //····················································································································
  //   Selection observable property: drawTraversingPads
  //····················································································································

  var drawTraversingPads_property = EBPropertyProxy_Bool ()

  //····················································································································
  //   Selection observable property: drawVias
  //····················································································································

  var drawVias_property = EBPropertyProxy_Bool ()

  //····················································································································
  //   Selection observable property: emptyFileExtensionImage
  //····················································································································

  var emptyFileExtensionImage_property = EBTransientProperty_NSImage ()

  //····················································································································
  //   Selection observable property: fileExtension
  //····················································································································

  var fileExtension_property = EBPropertyProxy_String ()

  //····················································································································
  //   Selection observable property: hasNoData
  //····················································································································

  var hasNoData_property = EBTransientProperty_Bool ()

  //····················································································································
  //   Selection observable property: horizontalMirror
  //····················································································································

  var horizontalMirror_property = EBPropertyProxy_Bool ()

  //····················································································································
  //   Selection observable property: mArtwork
  //····················································································································

  //····················································································································
  //   Selection observable property: measurementUnitForPadHoleInPDF
  //····················································································································

  var measurementUnitForPadHoleInPDF_property = EBPropertyProxy_Int ()

  //····················································································································
  //   Selection observable property: name
  //····················································································································

  var name_property = EBPropertyProxy_String ()

  //····················································································································
  //   Selection observable property: padHoleDiameterInPDF
  //····················································································································

  var padHoleDiameterInPDF_property = EBPropertyProxy_Int ()

  //····················································································································
  //   Selection observable property: parameterStatusImage
  //····················································································································

  var parameterStatusImage_property = EBTransientProperty_NSImage ()

  //····················································································································
  //   BIND SELECTION
  //····················································································································

  private var mModel : ReadOnlyArrayOf_ArtworkFileGenerationParameters? = nil

  //····················································································································

  final func bind_selection (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    self.mModel = model
    self.bind_property_drawBoardLimits (model: model)
    self.bind_property_drawComponentNamesBottomSide (model: model)
    self.bind_property_drawComponentNamesTopSide (model: model)
    self.bind_property_drawComponentValuesBottomSide (model: model)
    self.bind_property_drawComponentValuesTopSide (model: model)
    self.bind_property_drawInternalBoardLimits (model: model)
    self.bind_property_drawPackageLegendBottomSide (model: model)
    self.bind_property_drawPackageLegendTopSide (model: model)
    self.bind_property_drawPadHolesInPDF (model: model)
    self.bind_property_drawPadsBottomSide (model: model)
    self.bind_property_drawPadsTopSide (model: model)
    self.bind_property_drawTextsLayoutBottomSide (model: model)
    self.bind_property_drawTextsLayoutTopSide (model: model)
    self.bind_property_drawTextsLegendBottomSide (model: model)
    self.bind_property_drawTextsLegendTopSide (model: model)
    self.bind_property_drawTracksBottomSide (model: model)
    self.bind_property_drawTracksInner1Layer (model: model)
    self.bind_property_drawTracksInner2Layer (model: model)
    self.bind_property_drawTracksInner3Layer (model: model)
    self.bind_property_drawTracksInner4Layer (model: model)
    self.bind_property_drawTracksTopSide (model: model)
    self.bind_property_drawTraversingPads (model: model)
    self.bind_property_drawVias (model: model)
    self.bind_property_emptyFileExtensionImage (model: model)
    self.bind_property_fileExtension (model: model)
    self.bind_property_hasNoData (model: model)
    self.bind_property_horizontalMirror (model: model)
    self.bind_property_measurementUnitForPadHoleInPDF (model: model)
    self.bind_property_name (model: model)
    self.bind_property_padHoleDiameterInPDF (model: model)
    self.bind_property_parameterStatusImage (model: model)
  }

  //····················································································································
  //   UNBIND SELECTION
  //····················································································································

  final func unbind_selection () {
  //--- drawBoardLimits
    self.drawBoardLimits_property.mReadModelFunction = nil 
    self.drawBoardLimits_property.mWriteModelFunction = nil 
    self.drawBoardLimits_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_drawBoardLimits (self.drawBoardLimits_property)
  //--- drawComponentNamesBottomSide
    self.drawComponentNamesBottomSide_property.mReadModelFunction = nil 
    self.drawComponentNamesBottomSide_property.mWriteModelFunction = nil 
    self.drawComponentNamesBottomSide_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_drawComponentNamesBottomSide (self.drawComponentNamesBottomSide_property)
  //--- drawComponentNamesTopSide
    self.drawComponentNamesTopSide_property.mReadModelFunction = nil 
    self.drawComponentNamesTopSide_property.mWriteModelFunction = nil 
    self.drawComponentNamesTopSide_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_drawComponentNamesTopSide (self.drawComponentNamesTopSide_property)
  //--- drawComponentValuesBottomSide
    self.drawComponentValuesBottomSide_property.mReadModelFunction = nil 
    self.drawComponentValuesBottomSide_property.mWriteModelFunction = nil 
    self.drawComponentValuesBottomSide_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_drawComponentValuesBottomSide (self.drawComponentValuesBottomSide_property)
  //--- drawComponentValuesTopSide
    self.drawComponentValuesTopSide_property.mReadModelFunction = nil 
    self.drawComponentValuesTopSide_property.mWriteModelFunction = nil 
    self.drawComponentValuesTopSide_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_drawComponentValuesTopSide (self.drawComponentValuesTopSide_property)
  //--- drawInternalBoardLimits
    self.drawInternalBoardLimits_property.mReadModelFunction = nil 
    self.drawInternalBoardLimits_property.mWriteModelFunction = nil 
    self.drawInternalBoardLimits_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_drawInternalBoardLimits (self.drawInternalBoardLimits_property)
  //--- drawPackageLegendBottomSide
    self.drawPackageLegendBottomSide_property.mReadModelFunction = nil 
    self.drawPackageLegendBottomSide_property.mWriteModelFunction = nil 
    self.drawPackageLegendBottomSide_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_drawPackageLegendBottomSide (self.drawPackageLegendBottomSide_property)
  //--- drawPackageLegendTopSide
    self.drawPackageLegendTopSide_property.mReadModelFunction = nil 
    self.drawPackageLegendTopSide_property.mWriteModelFunction = nil 
    self.drawPackageLegendTopSide_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_drawPackageLegendTopSide (self.drawPackageLegendTopSide_property)
  //--- drawPadHolesInPDF
    self.drawPadHolesInPDF_property.mReadModelFunction = nil 
    self.drawPadHolesInPDF_property.mWriteModelFunction = nil 
    self.drawPadHolesInPDF_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_drawPadHolesInPDF (self.drawPadHolesInPDF_property)
  //--- drawPadsBottomSide
    self.drawPadsBottomSide_property.mReadModelFunction = nil 
    self.drawPadsBottomSide_property.mWriteModelFunction = nil 
    self.drawPadsBottomSide_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_drawPadsBottomSide (self.drawPadsBottomSide_property)
  //--- drawPadsTopSide
    self.drawPadsTopSide_property.mReadModelFunction = nil 
    self.drawPadsTopSide_property.mWriteModelFunction = nil 
    self.drawPadsTopSide_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_drawPadsTopSide (self.drawPadsTopSide_property)
  //--- drawTextsLayoutBottomSide
    self.drawTextsLayoutBottomSide_property.mReadModelFunction = nil 
    self.drawTextsLayoutBottomSide_property.mWriteModelFunction = nil 
    self.drawTextsLayoutBottomSide_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_drawTextsLayoutBottomSide (self.drawTextsLayoutBottomSide_property)
  //--- drawTextsLayoutTopSide
    self.drawTextsLayoutTopSide_property.mReadModelFunction = nil 
    self.drawTextsLayoutTopSide_property.mWriteModelFunction = nil 
    self.drawTextsLayoutTopSide_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_drawTextsLayoutTopSide (self.drawTextsLayoutTopSide_property)
  //--- drawTextsLegendBottomSide
    self.drawTextsLegendBottomSide_property.mReadModelFunction = nil 
    self.drawTextsLegendBottomSide_property.mWriteModelFunction = nil 
    self.drawTextsLegendBottomSide_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_drawTextsLegendBottomSide (self.drawTextsLegendBottomSide_property)
  //--- drawTextsLegendTopSide
    self.drawTextsLegendTopSide_property.mReadModelFunction = nil 
    self.drawTextsLegendTopSide_property.mWriteModelFunction = nil 
    self.drawTextsLegendTopSide_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_drawTextsLegendTopSide (self.drawTextsLegendTopSide_property)
  //--- drawTracksBottomSide
    self.drawTracksBottomSide_property.mReadModelFunction = nil 
    self.drawTracksBottomSide_property.mWriteModelFunction = nil 
    self.drawTracksBottomSide_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_drawTracksBottomSide (self.drawTracksBottomSide_property)
  //--- drawTracksInner1Layer
    self.drawTracksInner1Layer_property.mReadModelFunction = nil 
    self.drawTracksInner1Layer_property.mWriteModelFunction = nil 
    self.drawTracksInner1Layer_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_drawTracksInner1Layer (self.drawTracksInner1Layer_property)
  //--- drawTracksInner2Layer
    self.drawTracksInner2Layer_property.mReadModelFunction = nil 
    self.drawTracksInner2Layer_property.mWriteModelFunction = nil 
    self.drawTracksInner2Layer_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_drawTracksInner2Layer (self.drawTracksInner2Layer_property)
  //--- drawTracksInner3Layer
    self.drawTracksInner3Layer_property.mReadModelFunction = nil 
    self.drawTracksInner3Layer_property.mWriteModelFunction = nil 
    self.drawTracksInner3Layer_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_drawTracksInner3Layer (self.drawTracksInner3Layer_property)
  //--- drawTracksInner4Layer
    self.drawTracksInner4Layer_property.mReadModelFunction = nil 
    self.drawTracksInner4Layer_property.mWriteModelFunction = nil 
    self.drawTracksInner4Layer_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_drawTracksInner4Layer (self.drawTracksInner4Layer_property)
  //--- drawTracksTopSide
    self.drawTracksTopSide_property.mReadModelFunction = nil 
    self.drawTracksTopSide_property.mWriteModelFunction = nil 
    self.drawTracksTopSide_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_drawTracksTopSide (self.drawTracksTopSide_property)
  //--- drawTraversingPads
    self.drawTraversingPads_property.mReadModelFunction = nil 
    self.drawTraversingPads_property.mWriteModelFunction = nil 
    self.drawTraversingPads_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_drawTraversingPads (self.drawTraversingPads_property)
  //--- drawVias
    self.drawVias_property.mReadModelFunction = nil 
    self.drawVias_property.mWriteModelFunction = nil 
    self.drawVias_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_drawVias (self.drawVias_property)
  //--- emptyFileExtensionImage
    self.emptyFileExtensionImage_property.mReadModelFunction = nil 
    self.mModel?.removeEBObserverOf_emptyFileExtensionImage (self.emptyFileExtensionImage_property)
  //--- fileExtension
    self.fileExtension_property.mReadModelFunction = nil 
    self.fileExtension_property.mWriteModelFunction = nil 
    self.fileExtension_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_fileExtension (self.fileExtension_property)
  //--- hasNoData
    self.hasNoData_property.mReadModelFunction = nil 
    self.mModel?.removeEBObserverOf_hasNoData (self.hasNoData_property)
  //--- horizontalMirror
    self.horizontalMirror_property.mReadModelFunction = nil 
    self.horizontalMirror_property.mWriteModelFunction = nil 
    self.horizontalMirror_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_horizontalMirror (self.horizontalMirror_property)
  //--- measurementUnitForPadHoleInPDF
    self.measurementUnitForPadHoleInPDF_property.mReadModelFunction = nil 
    self.measurementUnitForPadHoleInPDF_property.mWriteModelFunction = nil 
    self.measurementUnitForPadHoleInPDF_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_measurementUnitForPadHoleInPDF (self.measurementUnitForPadHoleInPDF_property)
  //--- name
    self.name_property.mReadModelFunction = nil 
    self.name_property.mWriteModelFunction = nil 
    self.name_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_name (self.name_property)
  //--- padHoleDiameterInPDF
    self.padHoleDiameterInPDF_property.mReadModelFunction = nil 
    self.padHoleDiameterInPDF_property.mWriteModelFunction = nil 
    self.padHoleDiameterInPDF_property.mValidateAndWriteModelFunction = nil 
    self.mModel?.removeEBObserverOf_padHoleDiameterInPDF (self.padHoleDiameterInPDF_property)
  //--- parameterStatusImage
    self.parameterStatusImage_property.mReadModelFunction = nil 
    self.mModel?.removeEBObserverOf_parameterStatusImage (self.parameterStatusImage_property)
  //---
    self.mModel = nil
  }

  //····················································································································
  //    Explorer
  //····················································································································

  #if BUILD_OBJECT_EXPLORER
    private var mValueExplorer : NSButton?
    private var mExplorerWindow : NSWindow?
  #endif

  //····················································································································

  #if BUILD_OBJECT_EXPLORER
    final func addExplorer (name : String, y : inout CGFloat, view : NSView) {
      let font = NSFont.boldSystemFont (ofSize: NSFont.smallSystemFontSize)
      let tf = NSTextField (frame:secondColumn (y))
      tf.isEnabled = true
      tf.isEditable = false
      tf.stringValue = name
      tf.font = font
      view.addSubview (tf)
      let valueExplorer = NSButton (frame:thirdColumn (y))
      valueExplorer.font = font
      valueExplorer.title = self.explorerIndexString + " " + String (describing: type (of: self))
      valueExplorer.target = self
      valueExplorer.action = #selector(SelectionController_ProjectDocument_mDataSelection.showObjectWindowFromExplorerButton(_:))
      view.addSubview (valueExplorer)
      mValueExplorer = valueExplorer
      y += EXPLORER_ROW_HEIGHT
    }
  #endif

  //····················································································································

  #if BUILD_OBJECT_EXPLORER
    func buildExplorerWindow () {
    //-------------------------------------------------- Create Window
      let r = NSRect (x:20.0, y:20.0, width:10.0, height:10.0)
      mExplorerWindow = NSWindow (contentRect: r, styleMask: [.titled, .closable], backing: .buffered, defer: true, screen: nil)
    //-------------------------------------------------- Adding properties
      let view = NSView (frame:r)
      var y : CGFloat = 0.0
      createEntryForPropertyNamed (
        "drawBoardLimits",
        object: self.drawBoardLimits_property,
        y: &y,
        view: view,
        observerExplorer: &self.drawBoardLimits_property.mObserverExplorer,
        valueExplorer: &self.drawBoardLimits_property.mValueExplorer
      )
      createEntryForPropertyNamed (
        "drawComponentNamesBottomSide",
        object: self.drawComponentNamesBottomSide_property,
        y: &y,
        view: view,
        observerExplorer: &self.drawComponentNamesBottomSide_property.mObserverExplorer,
        valueExplorer: &self.drawComponentNamesBottomSide_property.mValueExplorer
      )
      createEntryForPropertyNamed (
        "drawComponentNamesTopSide",
        object: self.drawComponentNamesTopSide_property,
        y: &y,
        view: view,
        observerExplorer: &self.drawComponentNamesTopSide_property.mObserverExplorer,
        valueExplorer: &self.drawComponentNamesTopSide_property.mValueExplorer
      )
      createEntryForPropertyNamed (
        "drawComponentValuesBottomSide",
        object: self.drawComponentValuesBottomSide_property,
        y: &y,
        view: view,
        observerExplorer: &self.drawComponentValuesBottomSide_property.mObserverExplorer,
        valueExplorer: &self.drawComponentValuesBottomSide_property.mValueExplorer
      )
      createEntryForPropertyNamed (
        "drawComponentValuesTopSide",
        object: self.drawComponentValuesTopSide_property,
        y: &y,
        view: view,
        observerExplorer: &self.drawComponentValuesTopSide_property.mObserverExplorer,
        valueExplorer: &self.drawComponentValuesTopSide_property.mValueExplorer
      )
      createEntryForPropertyNamed (
        "drawInternalBoardLimits",
        object: self.drawInternalBoardLimits_property,
        y: &y,
        view: view,
        observerExplorer: &self.drawInternalBoardLimits_property.mObserverExplorer,
        valueExplorer: &self.drawInternalBoardLimits_property.mValueExplorer
      )
      createEntryForPropertyNamed (
        "drawPackageLegendBottomSide",
        object: self.drawPackageLegendBottomSide_property,
        y: &y,
        view: view,
        observerExplorer: &self.drawPackageLegendBottomSide_property.mObserverExplorer,
        valueExplorer: &self.drawPackageLegendBottomSide_property.mValueExplorer
      )
      createEntryForPropertyNamed (
        "drawPackageLegendTopSide",
        object: self.drawPackageLegendTopSide_property,
        y: &y,
        view: view,
        observerExplorer: &self.drawPackageLegendTopSide_property.mObserverExplorer,
        valueExplorer: &self.drawPackageLegendTopSide_property.mValueExplorer
      )
      createEntryForPropertyNamed (
        "drawPadHolesInPDF",
        object: self.drawPadHolesInPDF_property,
        y: &y,
        view: view,
        observerExplorer: &self.drawPadHolesInPDF_property.mObserverExplorer,
        valueExplorer: &self.drawPadHolesInPDF_property.mValueExplorer
      )
      createEntryForPropertyNamed (
        "drawPadsBottomSide",
        object: self.drawPadsBottomSide_property,
        y: &y,
        view: view,
        observerExplorer: &self.drawPadsBottomSide_property.mObserverExplorer,
        valueExplorer: &self.drawPadsBottomSide_property.mValueExplorer
      )
      createEntryForPropertyNamed (
        "drawPadsTopSide",
        object: self.drawPadsTopSide_property,
        y: &y,
        view: view,
        observerExplorer: &self.drawPadsTopSide_property.mObserverExplorer,
        valueExplorer: &self.drawPadsTopSide_property.mValueExplorer
      )
      createEntryForPropertyNamed (
        "drawTextsLayoutBottomSide",
        object: self.drawTextsLayoutBottomSide_property,
        y: &y,
        view: view,
        observerExplorer: &self.drawTextsLayoutBottomSide_property.mObserverExplorer,
        valueExplorer: &self.drawTextsLayoutBottomSide_property.mValueExplorer
      )
      createEntryForPropertyNamed (
        "drawTextsLayoutTopSide",
        object: self.drawTextsLayoutTopSide_property,
        y: &y,
        view: view,
        observerExplorer: &self.drawTextsLayoutTopSide_property.mObserverExplorer,
        valueExplorer: &self.drawTextsLayoutTopSide_property.mValueExplorer
      )
      createEntryForPropertyNamed (
        "drawTextsLegendBottomSide",
        object: self.drawTextsLegendBottomSide_property,
        y: &y,
        view: view,
        observerExplorer: &self.drawTextsLegendBottomSide_property.mObserverExplorer,
        valueExplorer: &self.drawTextsLegendBottomSide_property.mValueExplorer
      )
      createEntryForPropertyNamed (
        "drawTextsLegendTopSide",
        object: self.drawTextsLegendTopSide_property,
        y: &y,
        view: view,
        observerExplorer: &self.drawTextsLegendTopSide_property.mObserverExplorer,
        valueExplorer: &self.drawTextsLegendTopSide_property.mValueExplorer
      )
      createEntryForPropertyNamed (
        "drawTracksBottomSide",
        object: self.drawTracksBottomSide_property,
        y: &y,
        view: view,
        observerExplorer: &self.drawTracksBottomSide_property.mObserverExplorer,
        valueExplorer: &self.drawTracksBottomSide_property.mValueExplorer
      )
      createEntryForPropertyNamed (
        "drawTracksInner1Layer",
        object: self.drawTracksInner1Layer_property,
        y: &y,
        view: view,
        observerExplorer: &self.drawTracksInner1Layer_property.mObserverExplorer,
        valueExplorer: &self.drawTracksInner1Layer_property.mValueExplorer
      )
      createEntryForPropertyNamed (
        "drawTracksInner2Layer",
        object: self.drawTracksInner2Layer_property,
        y: &y,
        view: view,
        observerExplorer: &self.drawTracksInner2Layer_property.mObserverExplorer,
        valueExplorer: &self.drawTracksInner2Layer_property.mValueExplorer
      )
      createEntryForPropertyNamed (
        "drawTracksInner3Layer",
        object: self.drawTracksInner3Layer_property,
        y: &y,
        view: view,
        observerExplorer: &self.drawTracksInner3Layer_property.mObserverExplorer,
        valueExplorer: &self.drawTracksInner3Layer_property.mValueExplorer
      )
      createEntryForPropertyNamed (
        "drawTracksInner4Layer",
        object: self.drawTracksInner4Layer_property,
        y: &y,
        view: view,
        observerExplorer: &self.drawTracksInner4Layer_property.mObserverExplorer,
        valueExplorer: &self.drawTracksInner4Layer_property.mValueExplorer
      )
      createEntryForPropertyNamed (
        "drawTracksTopSide",
        object: self.drawTracksTopSide_property,
        y: &y,
        view: view,
        observerExplorer: &self.drawTracksTopSide_property.mObserverExplorer,
        valueExplorer: &self.drawTracksTopSide_property.mValueExplorer
      )
      createEntryForPropertyNamed (
        "drawTraversingPads",
        object: self.drawTraversingPads_property,
        y: &y,
        view: view,
        observerExplorer: &self.drawTraversingPads_property.mObserverExplorer,
        valueExplorer: &self.drawTraversingPads_property.mValueExplorer
      )
      createEntryForPropertyNamed (
        "drawVias",
        object: self.drawVias_property,
        y: &y,
        view: view,
        observerExplorer: &self.drawVias_property.mObserverExplorer,
        valueExplorer: &self.drawVias_property.mValueExplorer
      )
      createEntryForPropertyNamed (
        "fileExtension",
        object: self.fileExtension_property,
        y: &y,
        view: view,
        observerExplorer: &self.fileExtension_property.mObserverExplorer,
        valueExplorer: &self.fileExtension_property.mValueExplorer
      )
      createEntryForPropertyNamed (
        "horizontalMirror",
        object: self.horizontalMirror_property,
        y: &y,
        view: view,
        observerExplorer: &self.horizontalMirror_property.mObserverExplorer,
        valueExplorer: &self.horizontalMirror_property.mValueExplorer
      )
      createEntryForPropertyNamed (
        "measurementUnitForPadHoleInPDF",
        object: self.measurementUnitForPadHoleInPDF_property,
        y: &y,
        view: view,
        observerExplorer: &self.measurementUnitForPadHoleInPDF_property.mObserverExplorer,
        valueExplorer: &self.measurementUnitForPadHoleInPDF_property.mValueExplorer
      )
      createEntryForPropertyNamed (
        "name",
        object: self.name_property,
        y: &y,
        view: view,
        observerExplorer: &self.name_property.mObserverExplorer,
        valueExplorer: &self.name_property.mValueExplorer
      )
      createEntryForPropertyNamed (
        "padHoleDiameterInPDF",
        object: self.padHoleDiameterInPDF_property,
        y: &y,
        view: view,
        observerExplorer: &self.padHoleDiameterInPDF_property.mObserverExplorer,
        valueExplorer: &self.padHoleDiameterInPDF_property.mValueExplorer
      )
    //-------------------------------------------------- Finish Window construction
    //--- Resize View
      let viewFrame = NSRect (x:0.0, y:0.0, width:EXPLORER_ROW_WIDTH, height:y)
      view.frame = viewFrame
    //--- Set content size
      mExplorerWindow?.setContentSize (NSSize (width:EXPLORER_ROW_WIDTH + 16.0, height:fmin (600.0, y)))
    //--- Set close button as 'remove window' button
      let closeButton : NSButton? = mExplorerWindow?.standardWindowButton (.closeButton)
      closeButton?.target = self
      closeButton?.action = #selector(SelectionController_ProjectDocument_mDataSelection.deleteSelectionControllerWindowAction(_:))
    //--- Set window title
      let windowTitle = self.explorerIndexString + " " + String (describing: type (of: self))
      mExplorerWindow!.title = windowTitle
    //--- Add Scroll view
      let frame = NSRect (x:0.0, y:0.0, width:EXPLORER_ROW_WIDTH, height:y)
      let sw = NSScrollView (frame:frame)
      sw.hasVerticalScroller = true
      sw.documentView = view
      mExplorerWindow!.contentView = sw
    }
  #endif
  //····················································································································
  //   showObjectWindowFromExplorerButton
  //····················································································································

  #if BUILD_OBJECT_EXPLORER
    @objc func showObjectWindowFromExplorerButton (_ : Any) {
      if mExplorerWindow == nil {
        buildExplorerWindow ()
      }
      mExplorerWindow?.makeKeyAndOrderFront(nil)
    }
  #endif

  //····················································································································
  //   deleteSelectionControllerWindowAction
  //····················································································································

  #if BUILD_OBJECT_EXPLORER
    @objc func deleteSelectionControllerWindowAction (_ : Any) {
      clearObjectExplorer ()
    }
  #endif

  //····················································································································
  //   clearObjectExplorer
  //····················································································································

  #if BUILD_OBJECT_EXPLORER
    func clearObjectExplorer () {
      let closeButton = mExplorerWindow?.standardWindowButton (.closeButton)
      closeButton!.target = nil
      mExplorerWindow?.orderOut (nil)
      mExplorerWindow = nil
    }
  #endif

  //···················································································································*

  private final func bind_property_drawBoardLimits (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawBoardLimits (self.drawBoardLimits_property)
    self.drawBoardLimits_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawBoardLimits_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawBoardLimits_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawBoardLimits_property.setProp (inValue)
          }
        }
      }
    }
    self.drawBoardLimits_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawBoardLimits_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawComponentNamesBottomSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawComponentNamesBottomSide (self.drawComponentNamesBottomSide_property)
    self.drawComponentNamesBottomSide_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawComponentNamesBottomSide_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawComponentNamesBottomSide_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawComponentNamesBottomSide_property.setProp (inValue)
          }
        }
      }
    }
    self.drawComponentNamesBottomSide_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawComponentNamesBottomSide_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawComponentNamesTopSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawComponentNamesTopSide (self.drawComponentNamesTopSide_property)
    self.drawComponentNamesTopSide_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawComponentNamesTopSide_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawComponentNamesTopSide_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawComponentNamesTopSide_property.setProp (inValue)
          }
        }
      }
    }
    self.drawComponentNamesTopSide_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawComponentNamesTopSide_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawComponentValuesBottomSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawComponentValuesBottomSide (self.drawComponentValuesBottomSide_property)
    self.drawComponentValuesBottomSide_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawComponentValuesBottomSide_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawComponentValuesBottomSide_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawComponentValuesBottomSide_property.setProp (inValue)
          }
        }
      }
    }
    self.drawComponentValuesBottomSide_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawComponentValuesBottomSide_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawComponentValuesTopSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawComponentValuesTopSide (self.drawComponentValuesTopSide_property)
    self.drawComponentValuesTopSide_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawComponentValuesTopSide_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawComponentValuesTopSide_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawComponentValuesTopSide_property.setProp (inValue)
          }
        }
      }
    }
    self.drawComponentValuesTopSide_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawComponentValuesTopSide_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawInternalBoardLimits (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawInternalBoardLimits (self.drawInternalBoardLimits_property)
    self.drawInternalBoardLimits_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawInternalBoardLimits_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawInternalBoardLimits_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawInternalBoardLimits_property.setProp (inValue)
          }
        }
      }
    }
    self.drawInternalBoardLimits_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawInternalBoardLimits_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawPackageLegendBottomSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawPackageLegendBottomSide (self.drawPackageLegendBottomSide_property)
    self.drawPackageLegendBottomSide_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawPackageLegendBottomSide_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawPackageLegendBottomSide_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawPackageLegendBottomSide_property.setProp (inValue)
          }
        }
      }
    }
    self.drawPackageLegendBottomSide_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawPackageLegendBottomSide_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawPackageLegendTopSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawPackageLegendTopSide (self.drawPackageLegendTopSide_property)
    self.drawPackageLegendTopSide_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawPackageLegendTopSide_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawPackageLegendTopSide_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawPackageLegendTopSide_property.setProp (inValue)
          }
        }
      }
    }
    self.drawPackageLegendTopSide_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawPackageLegendTopSide_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawPadHolesInPDF (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawPadHolesInPDF (self.drawPadHolesInPDF_property)
    self.drawPadHolesInPDF_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawPadHolesInPDF_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawPadHolesInPDF_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawPadHolesInPDF_property.setProp (inValue)
          }
        }
      }
    }
    self.drawPadHolesInPDF_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawPadHolesInPDF_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawPadsBottomSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawPadsBottomSide (self.drawPadsBottomSide_property)
    self.drawPadsBottomSide_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawPadsBottomSide_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawPadsBottomSide_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawPadsBottomSide_property.setProp (inValue)
          }
        }
      }
    }
    self.drawPadsBottomSide_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawPadsBottomSide_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawPadsTopSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawPadsTopSide (self.drawPadsTopSide_property)
    self.drawPadsTopSide_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawPadsTopSide_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawPadsTopSide_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawPadsTopSide_property.setProp (inValue)
          }
        }
      }
    }
    self.drawPadsTopSide_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawPadsTopSide_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawTextsLayoutBottomSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawTextsLayoutBottomSide (self.drawTextsLayoutBottomSide_property)
    self.drawTextsLayoutBottomSide_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawTextsLayoutBottomSide_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawTextsLayoutBottomSide_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawTextsLayoutBottomSide_property.setProp (inValue)
          }
        }
      }
    }
    self.drawTextsLayoutBottomSide_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawTextsLayoutBottomSide_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawTextsLayoutTopSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawTextsLayoutTopSide (self.drawTextsLayoutTopSide_property)
    self.drawTextsLayoutTopSide_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawTextsLayoutTopSide_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawTextsLayoutTopSide_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawTextsLayoutTopSide_property.setProp (inValue)
          }
        }
      }
    }
    self.drawTextsLayoutTopSide_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawTextsLayoutTopSide_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawTextsLegendBottomSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawTextsLegendBottomSide (self.drawTextsLegendBottomSide_property)
    self.drawTextsLegendBottomSide_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawTextsLegendBottomSide_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawTextsLegendBottomSide_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawTextsLegendBottomSide_property.setProp (inValue)
          }
        }
      }
    }
    self.drawTextsLegendBottomSide_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawTextsLegendBottomSide_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawTextsLegendTopSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawTextsLegendTopSide (self.drawTextsLegendTopSide_property)
    self.drawTextsLegendTopSide_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawTextsLegendTopSide_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawTextsLegendTopSide_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawTextsLegendTopSide_property.setProp (inValue)
          }
        }
      }
    }
    self.drawTextsLegendTopSide_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawTextsLegendTopSide_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawTracksBottomSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawTracksBottomSide (self.drawTracksBottomSide_property)
    self.drawTracksBottomSide_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawTracksBottomSide_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawTracksBottomSide_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawTracksBottomSide_property.setProp (inValue)
          }
        }
      }
    }
    self.drawTracksBottomSide_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawTracksBottomSide_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawTracksInner1Layer (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawTracksInner1Layer (self.drawTracksInner1Layer_property)
    self.drawTracksInner1Layer_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawTracksInner1Layer_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawTracksInner1Layer_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawTracksInner1Layer_property.setProp (inValue)
          }
        }
      }
    }
    self.drawTracksInner1Layer_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawTracksInner1Layer_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawTracksInner2Layer (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawTracksInner2Layer (self.drawTracksInner2Layer_property)
    self.drawTracksInner2Layer_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawTracksInner2Layer_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawTracksInner2Layer_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawTracksInner2Layer_property.setProp (inValue)
          }
        }
      }
    }
    self.drawTracksInner2Layer_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawTracksInner2Layer_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawTracksInner3Layer (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawTracksInner3Layer (self.drawTracksInner3Layer_property)
    self.drawTracksInner3Layer_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawTracksInner3Layer_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawTracksInner3Layer_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawTracksInner3Layer_property.setProp (inValue)
          }
        }
      }
    }
    self.drawTracksInner3Layer_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawTracksInner3Layer_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawTracksInner4Layer (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawTracksInner4Layer (self.drawTracksInner4Layer_property)
    self.drawTracksInner4Layer_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawTracksInner4Layer_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawTracksInner4Layer_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawTracksInner4Layer_property.setProp (inValue)
          }
        }
      }
    }
    self.drawTracksInner4Layer_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawTracksInner4Layer_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawTracksTopSide (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawTracksTopSide (self.drawTracksTopSide_property)
    self.drawTracksTopSide_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawTracksTopSide_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawTracksTopSide_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawTracksTopSide_property.setProp (inValue)
          }
        }
      }
    }
    self.drawTracksTopSide_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawTracksTopSide_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawTraversingPads (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawTraversingPads (self.drawTraversingPads_property)
    self.drawTraversingPads_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawTraversingPads_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawTraversingPads_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawTraversingPads_property.setProp (inValue)
          }
        }
      }
    }
    self.drawTraversingPads_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawTraversingPads_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_drawVias (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_drawVias (self.drawVias_property)
    self.drawVias_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.drawVias_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.drawVias_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.drawVias_property.setProp (inValue)
          }
        }
      }
    }
    self.drawVias_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.drawVias_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_emptyFileExtensionImage (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_emptyFileExtensionImage (self.emptyFileExtensionImage_property)
    self.emptyFileExtensionImage_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <NSImage> ()
          var isMultipleSelection = false
          for object in v {
            switch object.emptyFileExtensionImage_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_fileExtension (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_fileExtension (self.fileExtension_property)
    self.fileExtension_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <String> ()
          var isMultipleSelection = false
          for object in v {
            switch object.fileExtension_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.fileExtension_property.mWriteModelFunction = { [weak self] (inValue : String) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.fileExtension_property.setProp (inValue)
          }
        }
      }
    }
    self.fileExtension_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : String, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.fileExtension_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_hasNoData (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_hasNoData (self.hasNoData_property)
    self.hasNoData_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.hasNoData_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }

  //···················································································································*

  private final func bind_property_horizontalMirror (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_horizontalMirror (self.horizontalMirror_property)
    self.horizontalMirror_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Bool> ()
          var isMultipleSelection = false
          for object in v {
            switch object.horizontalMirror_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.horizontalMirror_property.mWriteModelFunction = { [weak self] (inValue : Bool) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.horizontalMirror_property.setProp (inValue)
          }
        }
      }
    }
    self.horizontalMirror_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Bool, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.horizontalMirror_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_measurementUnitForPadHoleInPDF (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_measurementUnitForPadHoleInPDF (self.measurementUnitForPadHoleInPDF_property)
    self.measurementUnitForPadHoleInPDF_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.measurementUnitForPadHoleInPDF_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.measurementUnitForPadHoleInPDF_property.mWriteModelFunction = { [weak self] (inValue : Int) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.measurementUnitForPadHoleInPDF_property.setProp (inValue)
          }
        }
      }
    }
    self.measurementUnitForPadHoleInPDF_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.measurementUnitForPadHoleInPDF_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_name (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_name (self.name_property)
    self.name_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <String> ()
          var isMultipleSelection = false
          for object in v {
            switch object.name_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.name_property.mWriteModelFunction = { [weak self] (inValue : String) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.name_property.setProp (inValue)
          }
        }
      }
    }
    self.name_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : String, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.name_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_padHoleDiameterInPDF (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_padHoleDiameterInPDF (self.padHoleDiameterInPDF_property)
    self.padHoleDiameterInPDF_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <Int> ()
          var isMultipleSelection = false
          for object in v {
            switch object.padHoleDiameterInPDF_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
    self.padHoleDiameterInPDF_property.mWriteModelFunction = { [weak self] (inValue : Int) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          break
        case .single (let v) :
          for object in v {
            object.padHoleDiameterInPDF_property.setProp (inValue)
          }
        }
      }
    }
    self.padHoleDiameterInPDF_property.mValidateAndWriteModelFunction = { [weak self] (candidateValue : Int, windowForSheet : NSWindow?) in
      if let model = self?.mModel {
        switch model.selection {
        case .empty, .multiple :
          return false
        case .single (let v) :
          for object in v {
            let result = object.padHoleDiameterInPDF_property.validateAndSetProp (candidateValue, windowForSheet:windowForSheet)
            if !result {
              return false
            }
          }
          return true
        }
      }else{
        return false
      }
    }
  }

  //···················································································································*

  private final func bind_property_parameterStatusImage (model : ReadOnlyArrayOf_ArtworkFileGenerationParameters) {
    model.addEBObserverOf_parameterStatusImage (self.parameterStatusImage_property)
    self.parameterStatusImage_property.mReadModelFunction = { [weak self] in
      if let model = self?.mModel {
        switch model.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          var s = Set <NSImage> ()
          var isMultipleSelection = false
          for object in v {
            switch object.parameterStatusImage_property.selection {
            case .empty :
              return .empty
            case .multiple :
              isMultipleSelection = true
            case .single (let vProp) :
              s.insert (vProp)
            }
          }
          if isMultipleSelection {
            return .multiple
          }else if s.count == 0 {
            return .empty
          }else if s.count == 1 {
            return .single (s.first!)
          }else{
            return .multiple
          }
        }
      }else{
        return .empty
      }
    }
  }



  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

