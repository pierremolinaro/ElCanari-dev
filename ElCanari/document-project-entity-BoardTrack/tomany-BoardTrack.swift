//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  THIS FILE IS GENERATED BY EASY BINDINGS, DO NOT MODIFY IT
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

import AppKit

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    ReadOnlyArrayOf_BoardTrack
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class ReadOnlyArrayOf_BoardTrack : ReadOnlyAbstractArrayProperty <BoardTrack> {

  //····················································································································

  override func updateObservers (removedSet inRemovedSet : EBReferenceSet <BoardTrack>,                            
                                 addedSet inAddedSet : EBReferenceSet <BoardTrack>) {
    super.updateObservers (removedSet: inRemovedSet, addedSet: inAddedSet)
  //--- Remove observers from removed objects
    for managedObject in inRemovedSet.values {
      managedObject.mSide_property.stopsBeingObserved (by: self.mObserversOf_mSide) // Stored property
      managedObject.mDefaultTrackWidthUnit_property.stopsBeingObserved (by: self.mObserversOf_mDefaultTrackWidthUnit) // Stored property
      managedObject.mCustomTrackWidth_property.stopsBeingObserved (by: self.mObserversOf_mCustomTrackWidth) // Stored property
      managedObject.mCustomTrackWidthUnit_property.stopsBeingObserved (by: self.mObserversOf_mCustomTrackWidthUnit) // Stored property
      managedObject.mUsesCustomTrackWidth_property.stopsBeingObserved (by: self.mObserversOf_mUsesCustomTrackWidth) // Stored property
      managedObject.mIsPreservedByAutoRouter_property.stopsBeingObserved (by: self.mObserversOf_mIsPreservedByAutoRouter) // Stored property
      managedObject.mP1XUnit_property.stopsBeingObserved (by: self.mObserversOf_mP1XUnit) // Stored property
      managedObject.mP1YUnit_property.stopsBeingObserved (by: self.mObserversOf_mP1YUnit) // Stored property
      managedObject.mP2XUnit_property.stopsBeingObserved (by: self.mObserversOf_mP2XUnit) // Stored property
      managedObject.mP2YUnit_property.stopsBeingObserved (by: self.mObserversOf_mP2YUnit) // Stored property
      managedObject.mManualLockP1_property.stopsBeingObserved (by: self.mObserversOf_mManualLockP1) // Stored property
      managedObject.mManualLockP2_property.stopsBeingObserved (by: self.mObserversOf_mManualLockP2) // Stored property
      managedObject.mDirectionLockOnKnobDragging_property.stopsBeingObserved (by: self.mObserversOf_mDirectionLockOnKnobDragging) // Stored property
      managedObject.actualTrackWidth_property.stopsBeingObserved (by: self.mObserversOf_actualTrackWidth) // Transient property
      managedObject.netName_property.stopsBeingObserved (by: self.mObserversOf_netName) // Transient property
      managedObject.netClassName_property.stopsBeingObserved (by: self.mObserversOf_netClassName) // Transient property
      managedObject.netClassTrackWidth_property.stopsBeingObserved (by: self.mObserversOf_netClassTrackWidth) // Transient property
      managedObject.netClassViaHoleDiameter_property.stopsBeingObserved (by: self.mObserversOf_netClassViaHoleDiameter) // Transient property
      managedObject.netClassViaPadDiameter_property.stopsBeingObserved (by: self.mObserversOf_netClassViaPadDiameter) // Transient property
      managedObject.trackLengthInCanariUnit_property.stopsBeingObserved (by: self.mObserversOf_trackLengthInCanariUnit) // Transient property
      managedObject.trackSide_property.stopsBeingObserved (by: self.mObserversOf_trackSide) // Transient property
      managedObject.signatureForERCChecking_property.stopsBeingObserved (by: self.mObserversOf_signatureForERCChecking) // Transient property
      managedObject.p1ConnectedToSomePad_property.stopsBeingObserved (by: self.mObserversOf_p1ConnectedToSomePad) // Transient property
      managedObject.p2ConnectedToSomePad_property.stopsBeingObserved (by: self.mObserversOf_p2ConnectedToSomePad) // Transient property
      managedObject.objectDisplay_property.stopsBeingObserved (by: self.mObserversOf_objectDisplay) // Transient property
      managedObject.p1CanMove_property.stopsBeingObserved (by: self.mObserversOf_p1CanMove) // Transient property
      managedObject.p2CanMove_property.stopsBeingObserved (by: self.mObserversOf_p2CanMove) // Transient property
      managedObject.trackCanRotate_property.stopsBeingObserved (by: self.mObserversOf_trackCanRotate) // Transient property
      managedObject.selectionDisplay_property.stopsBeingObserved (by: self.mObserversOf_selectionDisplay) // Transient property
      managedObject.trackDirectionInDegrees_property.stopsBeingObserved (by: self.mObserversOf_trackDirectionInDegrees) // Computed property
      managedObject.computedP1X_property.stopsBeingObserved (by: self.mObserversOf_computedP1X) // Computed property
      managedObject.computedP1Y_property.stopsBeingObserved (by: self.mObserversOf_computedP1Y) // Computed property
      managedObject.computedP2X_property.stopsBeingObserved (by: self.mObserversOf_computedP2X) // Computed property
      managedObject.computedP2Y_property.stopsBeingObserved (by: self.mObserversOf_computedP2Y) // Computed property
    }
  //--- Add observers to added objects
    for managedObject in inAddedSet.values {
      managedObject.mSide_property.startsToBeObserved (by: self.mObserversOf_mSide) // Stored property
      managedObject.mDefaultTrackWidthUnit_property.startsToBeObserved (by: self.mObserversOf_mDefaultTrackWidthUnit) // Stored property
      managedObject.mCustomTrackWidth_property.startsToBeObserved (by: self.mObserversOf_mCustomTrackWidth) // Stored property
      managedObject.mCustomTrackWidthUnit_property.startsToBeObserved (by: self.mObserversOf_mCustomTrackWidthUnit) // Stored property
      managedObject.mUsesCustomTrackWidth_property.startsToBeObserved (by: self.mObserversOf_mUsesCustomTrackWidth) // Stored property
      managedObject.mIsPreservedByAutoRouter_property.startsToBeObserved (by: self.mObserversOf_mIsPreservedByAutoRouter) // Stored property
      managedObject.mP1XUnit_property.startsToBeObserved (by: self.mObserversOf_mP1XUnit) // Stored property
      managedObject.mP1YUnit_property.startsToBeObserved (by: self.mObserversOf_mP1YUnit) // Stored property
      managedObject.mP2XUnit_property.startsToBeObserved (by: self.mObserversOf_mP2XUnit) // Stored property
      managedObject.mP2YUnit_property.startsToBeObserved (by: self.mObserversOf_mP2YUnit) // Stored property
      managedObject.mManualLockP1_property.startsToBeObserved (by: self.mObserversOf_mManualLockP1) // Stored property
      managedObject.mManualLockP2_property.startsToBeObserved (by: self.mObserversOf_mManualLockP2) // Stored property
      managedObject.mDirectionLockOnKnobDragging_property.startsToBeObserved (by: self.mObserversOf_mDirectionLockOnKnobDragging) // Stored property
      managedObject.actualTrackWidth_property.startsToBeObserved (by: self.mObserversOf_actualTrackWidth) // Transient property
      managedObject.netName_property.startsToBeObserved (by: self.mObserversOf_netName) // Transient property
      managedObject.netClassName_property.startsToBeObserved (by: self.mObserversOf_netClassName) // Transient property
      managedObject.netClassTrackWidth_property.startsToBeObserved (by: self.mObserversOf_netClassTrackWidth) // Transient property
      managedObject.netClassViaHoleDiameter_property.startsToBeObserved (by: self.mObserversOf_netClassViaHoleDiameter) // Transient property
      managedObject.netClassViaPadDiameter_property.startsToBeObserved (by: self.mObserversOf_netClassViaPadDiameter) // Transient property
      managedObject.trackLengthInCanariUnit_property.startsToBeObserved (by: self.mObserversOf_trackLengthInCanariUnit) // Transient property
      managedObject.trackSide_property.startsToBeObserved (by: self.mObserversOf_trackSide) // Transient property
      managedObject.signatureForERCChecking_property.startsToBeObserved (by: self.mObserversOf_signatureForERCChecking) // Transient property
      managedObject.p1ConnectedToSomePad_property.startsToBeObserved (by: self.mObserversOf_p1ConnectedToSomePad) // Transient property
      managedObject.p2ConnectedToSomePad_property.startsToBeObserved (by: self.mObserversOf_p2ConnectedToSomePad) // Transient property
      managedObject.objectDisplay_property.startsToBeObserved (by: self.mObserversOf_objectDisplay) // Transient property
      managedObject.p1CanMove_property.startsToBeObserved (by: self.mObserversOf_p1CanMove) // Transient property
      managedObject.p2CanMove_property.startsToBeObserved (by: self.mObserversOf_p2CanMove) // Transient property
      managedObject.trackCanRotate_property.startsToBeObserved (by: self.mObserversOf_trackCanRotate) // Transient property
      managedObject.selectionDisplay_property.startsToBeObserved (by: self.mObserversOf_selectionDisplay) // Transient property
      managedObject.trackDirectionInDegrees_property.startsToBeObserved (by: self.mObserversOf_trackDirectionInDegrees) // Computed property
      managedObject.computedP1X_property.startsToBeObserved (by: self.mObserversOf_computedP1X) // Computed property
      managedObject.computedP1Y_property.startsToBeObserved (by: self.mObserversOf_computedP1Y) // Computed property
      managedObject.computedP2X_property.startsToBeObserved (by: self.mObserversOf_computedP2X) // Computed property
      managedObject.computedP2Y_property.startsToBeObserved (by: self.mObserversOf_computedP2Y) // Computed property
    }
  }

  //····················································································································
  //   Observers of 'mSide' stored property
  //····················································································································

  private final var mObserversOf_mSide = EBWeakObserverSetRelay ()

  //····················································································································

  final func toMany_mSide_StartsToBeObserved (by inObserver : EBObserverProtocol) {
    self.startsToBeObserved (by: inObserver)
    self.mObserversOf_mSide.insert (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.mSide_property.startsToBeObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  final func toMany_mSide_StopsBeingObserved (by inObserver : EBObserverProtocol) {
    self.stopsBeingObserved (by: inObserver)
    self.mObserversOf_mSide.remove (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.mSide_property.stopsBeingObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

 // final private func addEBObserversOf_mSide_toElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    /* for managedObject in inSet.values {
      managedObject.mSide_property.startsToBeObserved (by: self.mObserversOf_mSide)
    }*/
    /* if !self.mObserversOf_mSide.isEmpty {
      for managedObject in inSet.values {
        for entry in self.mObserversOf_mSide.values () {
          if let observer = entry.possibleObserver {
            managedObject.mSide_property.startsToBeObserved (by: observer)
          }else{
            self.mObserversOf_mSide.triggerPacking ()
          }
        }
      }
    } */
 // }

  //····················································································································

/*  final private func removeEBObserversOf_mSide_fromElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      managedObject.mSide_property.stopsBeingObserved (by: self.mObserversOf_mSide)
    }
    for entry in self.mObserversOf_mSide.values () {
      if let observer = entry.possibleObserver {
        observer.observedObjectDidChange ()
        for managedObject in inSet.values {
          managedObject.mSide_property.stopsBeingObserved (by: observer)
        }
      }else{
        self.mObserversOf_mSide.triggerPacking ()
      }
    }
  } */

  //····················································································································
  //   Observers of 'mDefaultTrackWidthUnit' stored property
  //····················································································································

  private final var mObserversOf_mDefaultTrackWidthUnit = EBWeakObserverSetRelay ()

  //····················································································································

  final func toMany_mDefaultTrackWidthUnit_StartsToBeObserved (by inObserver : EBObserverProtocol) {
    self.startsToBeObserved (by: inObserver)
    self.mObserversOf_mDefaultTrackWidthUnit.insert (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.mDefaultTrackWidthUnit_property.startsToBeObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  final func toMany_mDefaultTrackWidthUnit_StopsBeingObserved (by inObserver : EBObserverProtocol) {
    self.stopsBeingObserved (by: inObserver)
    self.mObserversOf_mDefaultTrackWidthUnit.remove (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.mDefaultTrackWidthUnit_property.stopsBeingObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

 // final private func addEBObserversOf_mDefaultTrackWidthUnit_toElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    /* for managedObject in inSet.values {
      managedObject.mDefaultTrackWidthUnit_property.startsToBeObserved (by: self.mObserversOf_mDefaultTrackWidthUnit)
    }*/
    /* if !self.mObserversOf_mDefaultTrackWidthUnit.isEmpty {
      for managedObject in inSet.values {
        for entry in self.mObserversOf_mDefaultTrackWidthUnit.values () {
          if let observer = entry.possibleObserver {
            managedObject.mDefaultTrackWidthUnit_property.startsToBeObserved (by: observer)
          }else{
            self.mObserversOf_mDefaultTrackWidthUnit.triggerPacking ()
          }
        }
      }
    } */
 // }

  //····················································································································

/*  final private func removeEBObserversOf_mDefaultTrackWidthUnit_fromElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      managedObject.mDefaultTrackWidthUnit_property.stopsBeingObserved (by: self.mObserversOf_mDefaultTrackWidthUnit)
    }
    for entry in self.mObserversOf_mDefaultTrackWidthUnit.values () {
      if let observer = entry.possibleObserver {
        observer.observedObjectDidChange ()
        for managedObject in inSet.values {
          managedObject.mDefaultTrackWidthUnit_property.stopsBeingObserved (by: observer)
        }
      }else{
        self.mObserversOf_mDefaultTrackWidthUnit.triggerPacking ()
      }
    }
  } */

  //····················································································································
  //   Observers of 'mCustomTrackWidth' stored property
  //····················································································································

  private final var mObserversOf_mCustomTrackWidth = EBWeakObserverSetRelay ()

  //····················································································································

  final func toMany_mCustomTrackWidth_StartsToBeObserved (by inObserver : EBObserverProtocol) {
    self.startsToBeObserved (by: inObserver)
    self.mObserversOf_mCustomTrackWidth.insert (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.mCustomTrackWidth_property.startsToBeObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  final func toMany_mCustomTrackWidth_StopsBeingObserved (by inObserver : EBObserverProtocol) {
    self.stopsBeingObserved (by: inObserver)
    self.mObserversOf_mCustomTrackWidth.remove (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.mCustomTrackWidth_property.stopsBeingObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

 // final private func addEBObserversOf_mCustomTrackWidth_toElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    /* for managedObject in inSet.values {
      managedObject.mCustomTrackWidth_property.startsToBeObserved (by: self.mObserversOf_mCustomTrackWidth)
    }*/
    /* if !self.mObserversOf_mCustomTrackWidth.isEmpty {
      for managedObject in inSet.values {
        for entry in self.mObserversOf_mCustomTrackWidth.values () {
          if let observer = entry.possibleObserver {
            managedObject.mCustomTrackWidth_property.startsToBeObserved (by: observer)
          }else{
            self.mObserversOf_mCustomTrackWidth.triggerPacking ()
          }
        }
      }
    } */
 // }

  //····················································································································

/*  final private func removeEBObserversOf_mCustomTrackWidth_fromElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      managedObject.mCustomTrackWidth_property.stopsBeingObserved (by: self.mObserversOf_mCustomTrackWidth)
    }
    for entry in self.mObserversOf_mCustomTrackWidth.values () {
      if let observer = entry.possibleObserver {
        observer.observedObjectDidChange ()
        for managedObject in inSet.values {
          managedObject.mCustomTrackWidth_property.stopsBeingObserved (by: observer)
        }
      }else{
        self.mObserversOf_mCustomTrackWidth.triggerPacking ()
      }
    }
  } */

  //····················································································································
  //   Observers of 'mCustomTrackWidthUnit' stored property
  //····················································································································

  private final var mObserversOf_mCustomTrackWidthUnit = EBWeakObserverSetRelay ()

  //····················································································································

  final func toMany_mCustomTrackWidthUnit_StartsToBeObserved (by inObserver : EBObserverProtocol) {
    self.startsToBeObserved (by: inObserver)
    self.mObserversOf_mCustomTrackWidthUnit.insert (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.mCustomTrackWidthUnit_property.startsToBeObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  final func toMany_mCustomTrackWidthUnit_StopsBeingObserved (by inObserver : EBObserverProtocol) {
    self.stopsBeingObserved (by: inObserver)
    self.mObserversOf_mCustomTrackWidthUnit.remove (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.mCustomTrackWidthUnit_property.stopsBeingObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

 // final private func addEBObserversOf_mCustomTrackWidthUnit_toElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    /* for managedObject in inSet.values {
      managedObject.mCustomTrackWidthUnit_property.startsToBeObserved (by: self.mObserversOf_mCustomTrackWidthUnit)
    }*/
    /* if !self.mObserversOf_mCustomTrackWidthUnit.isEmpty {
      for managedObject in inSet.values {
        for entry in self.mObserversOf_mCustomTrackWidthUnit.values () {
          if let observer = entry.possibleObserver {
            managedObject.mCustomTrackWidthUnit_property.startsToBeObserved (by: observer)
          }else{
            self.mObserversOf_mCustomTrackWidthUnit.triggerPacking ()
          }
        }
      }
    } */
 // }

  //····················································································································

/*  final private func removeEBObserversOf_mCustomTrackWidthUnit_fromElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      managedObject.mCustomTrackWidthUnit_property.stopsBeingObserved (by: self.mObserversOf_mCustomTrackWidthUnit)
    }
    for entry in self.mObserversOf_mCustomTrackWidthUnit.values () {
      if let observer = entry.possibleObserver {
        observer.observedObjectDidChange ()
        for managedObject in inSet.values {
          managedObject.mCustomTrackWidthUnit_property.stopsBeingObserved (by: observer)
        }
      }else{
        self.mObserversOf_mCustomTrackWidthUnit.triggerPacking ()
      }
    }
  } */

  //····················································································································
  //   Observers of 'mUsesCustomTrackWidth' stored property
  //····················································································································

  private final var mObserversOf_mUsesCustomTrackWidth = EBWeakObserverSetRelay ()

  //····················································································································

  final func toMany_mUsesCustomTrackWidth_StartsToBeObserved (by inObserver : EBObserverProtocol) {
    self.startsToBeObserved (by: inObserver)
    self.mObserversOf_mUsesCustomTrackWidth.insert (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.mUsesCustomTrackWidth_property.startsToBeObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  final func toMany_mUsesCustomTrackWidth_StopsBeingObserved (by inObserver : EBObserverProtocol) {
    self.stopsBeingObserved (by: inObserver)
    self.mObserversOf_mUsesCustomTrackWidth.remove (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.mUsesCustomTrackWidth_property.stopsBeingObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

 // final private func addEBObserversOf_mUsesCustomTrackWidth_toElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    /* for managedObject in inSet.values {
      managedObject.mUsesCustomTrackWidth_property.startsToBeObserved (by: self.mObserversOf_mUsesCustomTrackWidth)
    }*/
    /* if !self.mObserversOf_mUsesCustomTrackWidth.isEmpty {
      for managedObject in inSet.values {
        for entry in self.mObserversOf_mUsesCustomTrackWidth.values () {
          if let observer = entry.possibleObserver {
            managedObject.mUsesCustomTrackWidth_property.startsToBeObserved (by: observer)
          }else{
            self.mObserversOf_mUsesCustomTrackWidth.triggerPacking ()
          }
        }
      }
    } */
 // }

  //····················································································································

/*  final private func removeEBObserversOf_mUsesCustomTrackWidth_fromElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      managedObject.mUsesCustomTrackWidth_property.stopsBeingObserved (by: self.mObserversOf_mUsesCustomTrackWidth)
    }
    for entry in self.mObserversOf_mUsesCustomTrackWidth.values () {
      if let observer = entry.possibleObserver {
        observer.observedObjectDidChange ()
        for managedObject in inSet.values {
          managedObject.mUsesCustomTrackWidth_property.stopsBeingObserved (by: observer)
        }
      }else{
        self.mObserversOf_mUsesCustomTrackWidth.triggerPacking ()
      }
    }
  } */

  //····················································································································
  //   Observers of 'mIsPreservedByAutoRouter' stored property
  //····················································································································

  private final var mObserversOf_mIsPreservedByAutoRouter = EBWeakObserverSetRelay ()

  //····················································································································

  final func toMany_mIsPreservedByAutoRouter_StartsToBeObserved (by inObserver : EBObserverProtocol) {
    self.startsToBeObserved (by: inObserver)
    self.mObserversOf_mIsPreservedByAutoRouter.insert (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.mIsPreservedByAutoRouter_property.startsToBeObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  final func toMany_mIsPreservedByAutoRouter_StopsBeingObserved (by inObserver : EBObserverProtocol) {
    self.stopsBeingObserved (by: inObserver)
    self.mObserversOf_mIsPreservedByAutoRouter.remove (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.mIsPreservedByAutoRouter_property.stopsBeingObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

 // final private func addEBObserversOf_mIsPreservedByAutoRouter_toElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    /* for managedObject in inSet.values {
      managedObject.mIsPreservedByAutoRouter_property.startsToBeObserved (by: self.mObserversOf_mIsPreservedByAutoRouter)
    }*/
    /* if !self.mObserversOf_mIsPreservedByAutoRouter.isEmpty {
      for managedObject in inSet.values {
        for entry in self.mObserversOf_mIsPreservedByAutoRouter.values () {
          if let observer = entry.possibleObserver {
            managedObject.mIsPreservedByAutoRouter_property.startsToBeObserved (by: observer)
          }else{
            self.mObserversOf_mIsPreservedByAutoRouter.triggerPacking ()
          }
        }
      }
    } */
 // }

  //····················································································································

/*  final private func removeEBObserversOf_mIsPreservedByAutoRouter_fromElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      managedObject.mIsPreservedByAutoRouter_property.stopsBeingObserved (by: self.mObserversOf_mIsPreservedByAutoRouter)
    }
    for entry in self.mObserversOf_mIsPreservedByAutoRouter.values () {
      if let observer = entry.possibleObserver {
        observer.observedObjectDidChange ()
        for managedObject in inSet.values {
          managedObject.mIsPreservedByAutoRouter_property.stopsBeingObserved (by: observer)
        }
      }else{
        self.mObserversOf_mIsPreservedByAutoRouter.triggerPacking ()
      }
    }
  } */

  //····················································································································
  //   Observers of 'mP1XUnit' stored property
  //····················································································································

  private final var mObserversOf_mP1XUnit = EBWeakObserverSetRelay ()

  //····················································································································

  final func toMany_mP1XUnit_StartsToBeObserved (by inObserver : EBObserverProtocol) {
    self.startsToBeObserved (by: inObserver)
    self.mObserversOf_mP1XUnit.insert (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.mP1XUnit_property.startsToBeObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  final func toMany_mP1XUnit_StopsBeingObserved (by inObserver : EBObserverProtocol) {
    self.stopsBeingObserved (by: inObserver)
    self.mObserversOf_mP1XUnit.remove (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.mP1XUnit_property.stopsBeingObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

 // final private func addEBObserversOf_mP1XUnit_toElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    /* for managedObject in inSet.values {
      managedObject.mP1XUnit_property.startsToBeObserved (by: self.mObserversOf_mP1XUnit)
    }*/
    /* if !self.mObserversOf_mP1XUnit.isEmpty {
      for managedObject in inSet.values {
        for entry in self.mObserversOf_mP1XUnit.values () {
          if let observer = entry.possibleObserver {
            managedObject.mP1XUnit_property.startsToBeObserved (by: observer)
          }else{
            self.mObserversOf_mP1XUnit.triggerPacking ()
          }
        }
      }
    } */
 // }

  //····················································································································

/*  final private func removeEBObserversOf_mP1XUnit_fromElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      managedObject.mP1XUnit_property.stopsBeingObserved (by: self.mObserversOf_mP1XUnit)
    }
    for entry in self.mObserversOf_mP1XUnit.values () {
      if let observer = entry.possibleObserver {
        observer.observedObjectDidChange ()
        for managedObject in inSet.values {
          managedObject.mP1XUnit_property.stopsBeingObserved (by: observer)
        }
      }else{
        self.mObserversOf_mP1XUnit.triggerPacking ()
      }
    }
  } */

  //····················································································································
  //   Observers of 'mP1YUnit' stored property
  //····················································································································

  private final var mObserversOf_mP1YUnit = EBWeakObserverSetRelay ()

  //····················································································································

  final func toMany_mP1YUnit_StartsToBeObserved (by inObserver : EBObserverProtocol) {
    self.startsToBeObserved (by: inObserver)
    self.mObserversOf_mP1YUnit.insert (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.mP1YUnit_property.startsToBeObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  final func toMany_mP1YUnit_StopsBeingObserved (by inObserver : EBObserverProtocol) {
    self.stopsBeingObserved (by: inObserver)
    self.mObserversOf_mP1YUnit.remove (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.mP1YUnit_property.stopsBeingObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

 // final private func addEBObserversOf_mP1YUnit_toElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    /* for managedObject in inSet.values {
      managedObject.mP1YUnit_property.startsToBeObserved (by: self.mObserversOf_mP1YUnit)
    }*/
    /* if !self.mObserversOf_mP1YUnit.isEmpty {
      for managedObject in inSet.values {
        for entry in self.mObserversOf_mP1YUnit.values () {
          if let observer = entry.possibleObserver {
            managedObject.mP1YUnit_property.startsToBeObserved (by: observer)
          }else{
            self.mObserversOf_mP1YUnit.triggerPacking ()
          }
        }
      }
    } */
 // }

  //····················································································································

/*  final private func removeEBObserversOf_mP1YUnit_fromElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      managedObject.mP1YUnit_property.stopsBeingObserved (by: self.mObserversOf_mP1YUnit)
    }
    for entry in self.mObserversOf_mP1YUnit.values () {
      if let observer = entry.possibleObserver {
        observer.observedObjectDidChange ()
        for managedObject in inSet.values {
          managedObject.mP1YUnit_property.stopsBeingObserved (by: observer)
        }
      }else{
        self.mObserversOf_mP1YUnit.triggerPacking ()
      }
    }
  } */

  //····················································································································
  //   Observers of 'mP2XUnit' stored property
  //····················································································································

  private final var mObserversOf_mP2XUnit = EBWeakObserverSetRelay ()

  //····················································································································

  final func toMany_mP2XUnit_StartsToBeObserved (by inObserver : EBObserverProtocol) {
    self.startsToBeObserved (by: inObserver)
    self.mObserversOf_mP2XUnit.insert (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.mP2XUnit_property.startsToBeObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  final func toMany_mP2XUnit_StopsBeingObserved (by inObserver : EBObserverProtocol) {
    self.stopsBeingObserved (by: inObserver)
    self.mObserversOf_mP2XUnit.remove (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.mP2XUnit_property.stopsBeingObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

 // final private func addEBObserversOf_mP2XUnit_toElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    /* for managedObject in inSet.values {
      managedObject.mP2XUnit_property.startsToBeObserved (by: self.mObserversOf_mP2XUnit)
    }*/
    /* if !self.mObserversOf_mP2XUnit.isEmpty {
      for managedObject in inSet.values {
        for entry in self.mObserversOf_mP2XUnit.values () {
          if let observer = entry.possibleObserver {
            managedObject.mP2XUnit_property.startsToBeObserved (by: observer)
          }else{
            self.mObserversOf_mP2XUnit.triggerPacking ()
          }
        }
      }
    } */
 // }

  //····················································································································

/*  final private func removeEBObserversOf_mP2XUnit_fromElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      managedObject.mP2XUnit_property.stopsBeingObserved (by: self.mObserversOf_mP2XUnit)
    }
    for entry in self.mObserversOf_mP2XUnit.values () {
      if let observer = entry.possibleObserver {
        observer.observedObjectDidChange ()
        for managedObject in inSet.values {
          managedObject.mP2XUnit_property.stopsBeingObserved (by: observer)
        }
      }else{
        self.mObserversOf_mP2XUnit.triggerPacking ()
      }
    }
  } */

  //····················································································································
  //   Observers of 'mP2YUnit' stored property
  //····················································································································

  private final var mObserversOf_mP2YUnit = EBWeakObserverSetRelay ()

  //····················································································································

  final func toMany_mP2YUnit_StartsToBeObserved (by inObserver : EBObserverProtocol) {
    self.startsToBeObserved (by: inObserver)
    self.mObserversOf_mP2YUnit.insert (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.mP2YUnit_property.startsToBeObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  final func toMany_mP2YUnit_StopsBeingObserved (by inObserver : EBObserverProtocol) {
    self.stopsBeingObserved (by: inObserver)
    self.mObserversOf_mP2YUnit.remove (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.mP2YUnit_property.stopsBeingObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

 // final private func addEBObserversOf_mP2YUnit_toElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    /* for managedObject in inSet.values {
      managedObject.mP2YUnit_property.startsToBeObserved (by: self.mObserversOf_mP2YUnit)
    }*/
    /* if !self.mObserversOf_mP2YUnit.isEmpty {
      for managedObject in inSet.values {
        for entry in self.mObserversOf_mP2YUnit.values () {
          if let observer = entry.possibleObserver {
            managedObject.mP2YUnit_property.startsToBeObserved (by: observer)
          }else{
            self.mObserversOf_mP2YUnit.triggerPacking ()
          }
        }
      }
    } */
 // }

  //····················································································································

/*  final private func removeEBObserversOf_mP2YUnit_fromElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      managedObject.mP2YUnit_property.stopsBeingObserved (by: self.mObserversOf_mP2YUnit)
    }
    for entry in self.mObserversOf_mP2YUnit.values () {
      if let observer = entry.possibleObserver {
        observer.observedObjectDidChange ()
        for managedObject in inSet.values {
          managedObject.mP2YUnit_property.stopsBeingObserved (by: observer)
        }
      }else{
        self.mObserversOf_mP2YUnit.triggerPacking ()
      }
    }
  } */

  //····················································································································
  //   Observers of 'mManualLockP1' stored property
  //····················································································································

  private final var mObserversOf_mManualLockP1 = EBWeakObserverSetRelay ()

  //····················································································································

  final func toMany_mManualLockP1_StartsToBeObserved (by inObserver : EBObserverProtocol) {
    self.startsToBeObserved (by: inObserver)
    self.mObserversOf_mManualLockP1.insert (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.mManualLockP1_property.startsToBeObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  final func toMany_mManualLockP1_StopsBeingObserved (by inObserver : EBObserverProtocol) {
    self.stopsBeingObserved (by: inObserver)
    self.mObserversOf_mManualLockP1.remove (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.mManualLockP1_property.stopsBeingObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

 // final private func addEBObserversOf_mManualLockP1_toElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    /* for managedObject in inSet.values {
      managedObject.mManualLockP1_property.startsToBeObserved (by: self.mObserversOf_mManualLockP1)
    }*/
    /* if !self.mObserversOf_mManualLockP1.isEmpty {
      for managedObject in inSet.values {
        for entry in self.mObserversOf_mManualLockP1.values () {
          if let observer = entry.possibleObserver {
            managedObject.mManualLockP1_property.startsToBeObserved (by: observer)
          }else{
            self.mObserversOf_mManualLockP1.triggerPacking ()
          }
        }
      }
    } */
 // }

  //····················································································································

/*  final private func removeEBObserversOf_mManualLockP1_fromElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      managedObject.mManualLockP1_property.stopsBeingObserved (by: self.mObserversOf_mManualLockP1)
    }
    for entry in self.mObserversOf_mManualLockP1.values () {
      if let observer = entry.possibleObserver {
        observer.observedObjectDidChange ()
        for managedObject in inSet.values {
          managedObject.mManualLockP1_property.stopsBeingObserved (by: observer)
        }
      }else{
        self.mObserversOf_mManualLockP1.triggerPacking ()
      }
    }
  } */

  //····················································································································
  //   Observers of 'mManualLockP2' stored property
  //····················································································································

  private final var mObserversOf_mManualLockP2 = EBWeakObserverSetRelay ()

  //····················································································································

  final func toMany_mManualLockP2_StartsToBeObserved (by inObserver : EBObserverProtocol) {
    self.startsToBeObserved (by: inObserver)
    self.mObserversOf_mManualLockP2.insert (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.mManualLockP2_property.startsToBeObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  final func toMany_mManualLockP2_StopsBeingObserved (by inObserver : EBObserverProtocol) {
    self.stopsBeingObserved (by: inObserver)
    self.mObserversOf_mManualLockP2.remove (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.mManualLockP2_property.stopsBeingObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

 // final private func addEBObserversOf_mManualLockP2_toElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    /* for managedObject in inSet.values {
      managedObject.mManualLockP2_property.startsToBeObserved (by: self.mObserversOf_mManualLockP2)
    }*/
    /* if !self.mObserversOf_mManualLockP2.isEmpty {
      for managedObject in inSet.values {
        for entry in self.mObserversOf_mManualLockP2.values () {
          if let observer = entry.possibleObserver {
            managedObject.mManualLockP2_property.startsToBeObserved (by: observer)
          }else{
            self.mObserversOf_mManualLockP2.triggerPacking ()
          }
        }
      }
    } */
 // }

  //····················································································································

/*  final private func removeEBObserversOf_mManualLockP2_fromElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      managedObject.mManualLockP2_property.stopsBeingObserved (by: self.mObserversOf_mManualLockP2)
    }
    for entry in self.mObserversOf_mManualLockP2.values () {
      if let observer = entry.possibleObserver {
        observer.observedObjectDidChange ()
        for managedObject in inSet.values {
          managedObject.mManualLockP2_property.stopsBeingObserved (by: observer)
        }
      }else{
        self.mObserversOf_mManualLockP2.triggerPacking ()
      }
    }
  } */

  //····················································································································
  //   Observers of 'mDirectionLockOnKnobDragging' stored property
  //····················································································································

  private final var mObserversOf_mDirectionLockOnKnobDragging = EBWeakObserverSetRelay ()

  //····················································································································

  final func toMany_mDirectionLockOnKnobDragging_StartsToBeObserved (by inObserver : EBObserverProtocol) {
    self.startsToBeObserved (by: inObserver)
    self.mObserversOf_mDirectionLockOnKnobDragging.insert (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.mDirectionLockOnKnobDragging_property.startsToBeObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  final func toMany_mDirectionLockOnKnobDragging_StopsBeingObserved (by inObserver : EBObserverProtocol) {
    self.stopsBeingObserved (by: inObserver)
    self.mObserversOf_mDirectionLockOnKnobDragging.remove (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.mDirectionLockOnKnobDragging_property.stopsBeingObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

 // final private func addEBObserversOf_mDirectionLockOnKnobDragging_toElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    /* for managedObject in inSet.values {
      managedObject.mDirectionLockOnKnobDragging_property.startsToBeObserved (by: self.mObserversOf_mDirectionLockOnKnobDragging)
    }*/
    /* if !self.mObserversOf_mDirectionLockOnKnobDragging.isEmpty {
      for managedObject in inSet.values {
        for entry in self.mObserversOf_mDirectionLockOnKnobDragging.values () {
          if let observer = entry.possibleObserver {
            managedObject.mDirectionLockOnKnobDragging_property.startsToBeObserved (by: observer)
          }else{
            self.mObserversOf_mDirectionLockOnKnobDragging.triggerPacking ()
          }
        }
      }
    } */
 // }

  //····················································································································

/*  final private func removeEBObserversOf_mDirectionLockOnKnobDragging_fromElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      managedObject.mDirectionLockOnKnobDragging_property.stopsBeingObserved (by: self.mObserversOf_mDirectionLockOnKnobDragging)
    }
    for entry in self.mObserversOf_mDirectionLockOnKnobDragging.values () {
      if let observer = entry.possibleObserver {
        observer.observedObjectDidChange ()
        for managedObject in inSet.values {
          managedObject.mDirectionLockOnKnobDragging_property.stopsBeingObserved (by: observer)
        }
      }else{
        self.mObserversOf_mDirectionLockOnKnobDragging.triggerPacking ()
      }
    }
  } */

  //····················································································································
  //   Observers of 'actualTrackWidth' transient property
  //····················································································································

  private final var mObserversOf_actualTrackWidth = EBWeakObserverSetRelay ()

  //····················································································································

  final func toMany_actualTrackWidth_StartsToBeObserved (by inObserver : EBObserverProtocol) {
    self.startsToBeObserved (by: inObserver)
    self.mObserversOf_actualTrackWidth.insert (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.actualTrackWidth_property.startsToBeObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  final func toMany_actualTrackWidth_StopsBeingObserved (by inObserver : EBObserverProtocol) {
    self.stopsBeingObserved (by: inObserver)
    self.mObserversOf_actualTrackWidth.remove (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.actualTrackWidth_property.stopsBeingObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  /* final private func addEBObserversOf_actualTrackWidth_toElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      for entry in self.mObserversOf_actualTrackWidth.values () {
        if let observer = entry.possibleObserver {
          managedObject.actualTrackWidth_property.startsToBeObserved (by: observer)
        }else{
          self.mObserversOf_actualTrackWidth.triggerPacking ()
        }
      }
    }
  } */

  //····················································································································

  /* final private func removeEBObserversOf_actualTrackWidth_fromElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      for entry in self.mObserversOf_actualTrackWidth.values () {
        if let observer = entry.possibleObserver {
          managedObject.actualTrackWidth_property.stopsBeingObserved (by: observer)
        }else{
          self.mObserversOf_actualTrackWidth.triggerPacking ()
        }
      }
    }
  } */

  //····················································································································
  //   Observers of 'netName' transient property
  //····················································································································

  private final var mObserversOf_netName = EBWeakObserverSetRelay ()

  //····················································································································

  final func toMany_netName_StartsToBeObserved (by inObserver : EBObserverProtocol) {
    self.startsToBeObserved (by: inObserver)
    self.mObserversOf_netName.insert (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.netName_property.startsToBeObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  final func toMany_netName_StopsBeingObserved (by inObserver : EBObserverProtocol) {
    self.stopsBeingObserved (by: inObserver)
    self.mObserversOf_netName.remove (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.netName_property.stopsBeingObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  /* final private func addEBObserversOf_netName_toElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      for entry in self.mObserversOf_netName.values () {
        if let observer = entry.possibleObserver {
          managedObject.netName_property.startsToBeObserved (by: observer)
        }else{
          self.mObserversOf_netName.triggerPacking ()
        }
      }
    }
  } */

  //····················································································································

  /* final private func removeEBObserversOf_netName_fromElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      for entry in self.mObserversOf_netName.values () {
        if let observer = entry.possibleObserver {
          managedObject.netName_property.stopsBeingObserved (by: observer)
        }else{
          self.mObserversOf_netName.triggerPacking ()
        }
      }
    }
  } */

  //····················································································································
  //   Observers of 'netClassName' transient property
  //····················································································································

  private final var mObserversOf_netClassName = EBWeakObserverSetRelay ()

  //····················································································································

  final func toMany_netClassName_StartsToBeObserved (by inObserver : EBObserverProtocol) {
    self.startsToBeObserved (by: inObserver)
    self.mObserversOf_netClassName.insert (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.netClassName_property.startsToBeObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  final func toMany_netClassName_StopsBeingObserved (by inObserver : EBObserverProtocol) {
    self.stopsBeingObserved (by: inObserver)
    self.mObserversOf_netClassName.remove (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.netClassName_property.stopsBeingObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  /* final private func addEBObserversOf_netClassName_toElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      for entry in self.mObserversOf_netClassName.values () {
        if let observer = entry.possibleObserver {
          managedObject.netClassName_property.startsToBeObserved (by: observer)
        }else{
          self.mObserversOf_netClassName.triggerPacking ()
        }
      }
    }
  } */

  //····················································································································

  /* final private func removeEBObserversOf_netClassName_fromElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      for entry in self.mObserversOf_netClassName.values () {
        if let observer = entry.possibleObserver {
          managedObject.netClassName_property.stopsBeingObserved (by: observer)
        }else{
          self.mObserversOf_netClassName.triggerPacking ()
        }
      }
    }
  } */

  //····················································································································
  //   Observers of 'netClassTrackWidth' transient property
  //····················································································································

  private final var mObserversOf_netClassTrackWidth = EBWeakObserverSetRelay ()

  //····················································································································

  final func toMany_netClassTrackWidth_StartsToBeObserved (by inObserver : EBObserverProtocol) {
    self.startsToBeObserved (by: inObserver)
    self.mObserversOf_netClassTrackWidth.insert (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.netClassTrackWidth_property.startsToBeObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  final func toMany_netClassTrackWidth_StopsBeingObserved (by inObserver : EBObserverProtocol) {
    self.stopsBeingObserved (by: inObserver)
    self.mObserversOf_netClassTrackWidth.remove (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.netClassTrackWidth_property.stopsBeingObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  /* final private func addEBObserversOf_netClassTrackWidth_toElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      for entry in self.mObserversOf_netClassTrackWidth.values () {
        if let observer = entry.possibleObserver {
          managedObject.netClassTrackWidth_property.startsToBeObserved (by: observer)
        }else{
          self.mObserversOf_netClassTrackWidth.triggerPacking ()
        }
      }
    }
  } */

  //····················································································································

  /* final private func removeEBObserversOf_netClassTrackWidth_fromElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      for entry in self.mObserversOf_netClassTrackWidth.values () {
        if let observer = entry.possibleObserver {
          managedObject.netClassTrackWidth_property.stopsBeingObserved (by: observer)
        }else{
          self.mObserversOf_netClassTrackWidth.triggerPacking ()
        }
      }
    }
  } */

  //····················································································································
  //   Observers of 'netClassViaHoleDiameter' transient property
  //····················································································································

  private final var mObserversOf_netClassViaHoleDiameter = EBWeakObserverSetRelay ()

  //····················································································································

  final func toMany_netClassViaHoleDiameter_StartsToBeObserved (by inObserver : EBObserverProtocol) {
    self.startsToBeObserved (by: inObserver)
    self.mObserversOf_netClassViaHoleDiameter.insert (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.netClassViaHoleDiameter_property.startsToBeObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  final func toMany_netClassViaHoleDiameter_StopsBeingObserved (by inObserver : EBObserverProtocol) {
    self.stopsBeingObserved (by: inObserver)
    self.mObserversOf_netClassViaHoleDiameter.remove (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.netClassViaHoleDiameter_property.stopsBeingObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  /* final private func addEBObserversOf_netClassViaHoleDiameter_toElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      for entry in self.mObserversOf_netClassViaHoleDiameter.values () {
        if let observer = entry.possibleObserver {
          managedObject.netClassViaHoleDiameter_property.startsToBeObserved (by: observer)
        }else{
          self.mObserversOf_netClassViaHoleDiameter.triggerPacking ()
        }
      }
    }
  } */

  //····················································································································

  /* final private func removeEBObserversOf_netClassViaHoleDiameter_fromElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      for entry in self.mObserversOf_netClassViaHoleDiameter.values () {
        if let observer = entry.possibleObserver {
          managedObject.netClassViaHoleDiameter_property.stopsBeingObserved (by: observer)
        }else{
          self.mObserversOf_netClassViaHoleDiameter.triggerPacking ()
        }
      }
    }
  } */

  //····················································································································
  //   Observers of 'netClassViaPadDiameter' transient property
  //····················································································································

  private final var mObserversOf_netClassViaPadDiameter = EBWeakObserverSetRelay ()

  //····················································································································

  final func toMany_netClassViaPadDiameter_StartsToBeObserved (by inObserver : EBObserverProtocol) {
    self.startsToBeObserved (by: inObserver)
    self.mObserversOf_netClassViaPadDiameter.insert (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.netClassViaPadDiameter_property.startsToBeObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  final func toMany_netClassViaPadDiameter_StopsBeingObserved (by inObserver : EBObserverProtocol) {
    self.stopsBeingObserved (by: inObserver)
    self.mObserversOf_netClassViaPadDiameter.remove (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.netClassViaPadDiameter_property.stopsBeingObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  /* final private func addEBObserversOf_netClassViaPadDiameter_toElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      for entry in self.mObserversOf_netClassViaPadDiameter.values () {
        if let observer = entry.possibleObserver {
          managedObject.netClassViaPadDiameter_property.startsToBeObserved (by: observer)
        }else{
          self.mObserversOf_netClassViaPadDiameter.triggerPacking ()
        }
      }
    }
  } */

  //····················································································································

  /* final private func removeEBObserversOf_netClassViaPadDiameter_fromElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      for entry in self.mObserversOf_netClassViaPadDiameter.values () {
        if let observer = entry.possibleObserver {
          managedObject.netClassViaPadDiameter_property.stopsBeingObserved (by: observer)
        }else{
          self.mObserversOf_netClassViaPadDiameter.triggerPacking ()
        }
      }
    }
  } */

  //····················································································································
  //   Observers of 'trackLengthInCanariUnit' transient property
  //····················································································································

  private final var mObserversOf_trackLengthInCanariUnit = EBWeakObserverSetRelay ()

  //····················································································································

  final func toMany_trackLengthInCanariUnit_StartsToBeObserved (by inObserver : EBObserverProtocol) {
    self.startsToBeObserved (by: inObserver)
    self.mObserversOf_trackLengthInCanariUnit.insert (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.trackLengthInCanariUnit_property.startsToBeObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  final func toMany_trackLengthInCanariUnit_StopsBeingObserved (by inObserver : EBObserverProtocol) {
    self.stopsBeingObserved (by: inObserver)
    self.mObserversOf_trackLengthInCanariUnit.remove (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.trackLengthInCanariUnit_property.stopsBeingObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  /* final private func addEBObserversOf_trackLengthInCanariUnit_toElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      for entry in self.mObserversOf_trackLengthInCanariUnit.values () {
        if let observer = entry.possibleObserver {
          managedObject.trackLengthInCanariUnit_property.startsToBeObserved (by: observer)
        }else{
          self.mObserversOf_trackLengthInCanariUnit.triggerPacking ()
        }
      }
    }
  } */

  //····················································································································

  /* final private func removeEBObserversOf_trackLengthInCanariUnit_fromElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      for entry in self.mObserversOf_trackLengthInCanariUnit.values () {
        if let observer = entry.possibleObserver {
          managedObject.trackLengthInCanariUnit_property.stopsBeingObserved (by: observer)
        }else{
          self.mObserversOf_trackLengthInCanariUnit.triggerPacking ()
        }
      }
    }
  } */

  //····················································································································
  //   Observers of 'trackSide' transient property
  //····················································································································

  private final var mObserversOf_trackSide = EBWeakObserverSetRelay ()

  //····················································································································

  final func toMany_trackSide_StartsToBeObserved (by inObserver : EBObserverProtocol) {
    self.startsToBeObserved (by: inObserver)
    self.mObserversOf_trackSide.insert (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.trackSide_property.startsToBeObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  final func toMany_trackSide_StopsBeingObserved (by inObserver : EBObserverProtocol) {
    self.stopsBeingObserved (by: inObserver)
    self.mObserversOf_trackSide.remove (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.trackSide_property.stopsBeingObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  /* final private func addEBObserversOf_trackSide_toElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      for entry in self.mObserversOf_trackSide.values () {
        if let observer = entry.possibleObserver {
          managedObject.trackSide_property.startsToBeObserved (by: observer)
        }else{
          self.mObserversOf_trackSide.triggerPacking ()
        }
      }
    }
  } */

  //····················································································································

  /* final private func removeEBObserversOf_trackSide_fromElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      for entry in self.mObserversOf_trackSide.values () {
        if let observer = entry.possibleObserver {
          managedObject.trackSide_property.stopsBeingObserved (by: observer)
        }else{
          self.mObserversOf_trackSide.triggerPacking ()
        }
      }
    }
  } */

  //····················································································································
  //   Observers of 'signatureForERCChecking' transient property
  //····················································································································

  private final var mObserversOf_signatureForERCChecking = EBWeakObserverSetRelay ()

  //····················································································································

  final func toMany_signatureForERCChecking_StartsToBeObserved (by inObserver : EBObserverProtocol) {
    self.startsToBeObserved (by: inObserver)
    self.mObserversOf_signatureForERCChecking.insert (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.signatureForERCChecking_property.startsToBeObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  final func toMany_signatureForERCChecking_StopsBeingObserved (by inObserver : EBObserverProtocol) {
    self.stopsBeingObserved (by: inObserver)
    self.mObserversOf_signatureForERCChecking.remove (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.signatureForERCChecking_property.stopsBeingObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  /* final private func addEBObserversOf_signatureForERCChecking_toElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      for entry in self.mObserversOf_signatureForERCChecking.values () {
        if let observer = entry.possibleObserver {
          managedObject.signatureForERCChecking_property.startsToBeObserved (by: observer)
        }else{
          self.mObserversOf_signatureForERCChecking.triggerPacking ()
        }
      }
    }
  } */

  //····················································································································

  /* final private func removeEBObserversOf_signatureForERCChecking_fromElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      for entry in self.mObserversOf_signatureForERCChecking.values () {
        if let observer = entry.possibleObserver {
          managedObject.signatureForERCChecking_property.stopsBeingObserved (by: observer)
        }else{
          self.mObserversOf_signatureForERCChecking.triggerPacking ()
        }
      }
    }
  } */

  //····················································································································
  //   Observers of 'p1ConnectedToSomePad' transient property
  //····················································································································

  private final var mObserversOf_p1ConnectedToSomePad = EBWeakObserverSetRelay ()

  //····················································································································

  final func toMany_p1ConnectedToSomePad_StartsToBeObserved (by inObserver : EBObserverProtocol) {
    self.startsToBeObserved (by: inObserver)
    self.mObserversOf_p1ConnectedToSomePad.insert (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.p1ConnectedToSomePad_property.startsToBeObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  final func toMany_p1ConnectedToSomePad_StopsBeingObserved (by inObserver : EBObserverProtocol) {
    self.stopsBeingObserved (by: inObserver)
    self.mObserversOf_p1ConnectedToSomePad.remove (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.p1ConnectedToSomePad_property.stopsBeingObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  /* final private func addEBObserversOf_p1ConnectedToSomePad_toElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      for entry in self.mObserversOf_p1ConnectedToSomePad.values () {
        if let observer = entry.possibleObserver {
          managedObject.p1ConnectedToSomePad_property.startsToBeObserved (by: observer)
        }else{
          self.mObserversOf_p1ConnectedToSomePad.triggerPacking ()
        }
      }
    }
  } */

  //····················································································································

  /* final private func removeEBObserversOf_p1ConnectedToSomePad_fromElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      for entry in self.mObserversOf_p1ConnectedToSomePad.values () {
        if let observer = entry.possibleObserver {
          managedObject.p1ConnectedToSomePad_property.stopsBeingObserved (by: observer)
        }else{
          self.mObserversOf_p1ConnectedToSomePad.triggerPacking ()
        }
      }
    }
  } */

  //····················································································································
  //   Observers of 'p2ConnectedToSomePad' transient property
  //····················································································································

  private final var mObserversOf_p2ConnectedToSomePad = EBWeakObserverSetRelay ()

  //····················································································································

  final func toMany_p2ConnectedToSomePad_StartsToBeObserved (by inObserver : EBObserverProtocol) {
    self.startsToBeObserved (by: inObserver)
    self.mObserversOf_p2ConnectedToSomePad.insert (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.p2ConnectedToSomePad_property.startsToBeObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  final func toMany_p2ConnectedToSomePad_StopsBeingObserved (by inObserver : EBObserverProtocol) {
    self.stopsBeingObserved (by: inObserver)
    self.mObserversOf_p2ConnectedToSomePad.remove (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.p2ConnectedToSomePad_property.stopsBeingObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  /* final private func addEBObserversOf_p2ConnectedToSomePad_toElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      for entry in self.mObserversOf_p2ConnectedToSomePad.values () {
        if let observer = entry.possibleObserver {
          managedObject.p2ConnectedToSomePad_property.startsToBeObserved (by: observer)
        }else{
          self.mObserversOf_p2ConnectedToSomePad.triggerPacking ()
        }
      }
    }
  } */

  //····················································································································

  /* final private func removeEBObserversOf_p2ConnectedToSomePad_fromElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      for entry in self.mObserversOf_p2ConnectedToSomePad.values () {
        if let observer = entry.possibleObserver {
          managedObject.p2ConnectedToSomePad_property.stopsBeingObserved (by: observer)
        }else{
          self.mObserversOf_p2ConnectedToSomePad.triggerPacking ()
        }
      }
    }
  } */

  //····················································································································
  //   Observers of 'objectDisplay' transient property
  //····················································································································

  private final var mObserversOf_objectDisplay = EBWeakObserverSetRelay ()

  //····················································································································

  final func toMany_objectDisplay_StartsToBeObserved (by inObserver : EBObserverProtocol) {
    self.startsToBeObserved (by: inObserver)
    self.mObserversOf_objectDisplay.insert (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.objectDisplay_property.startsToBeObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  final func toMany_objectDisplay_StopsBeingObserved (by inObserver : EBObserverProtocol) {
    self.stopsBeingObserved (by: inObserver)
    self.mObserversOf_objectDisplay.remove (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.objectDisplay_property.stopsBeingObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  /* final private func addEBObserversOf_objectDisplay_toElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      for entry in self.mObserversOf_objectDisplay.values () {
        if let observer = entry.possibleObserver {
          managedObject.objectDisplay_property.startsToBeObserved (by: observer)
        }else{
          self.mObserversOf_objectDisplay.triggerPacking ()
        }
      }
    }
  } */

  //····················································································································

  /* final private func removeEBObserversOf_objectDisplay_fromElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      for entry in self.mObserversOf_objectDisplay.values () {
        if let observer = entry.possibleObserver {
          managedObject.objectDisplay_property.stopsBeingObserved (by: observer)
        }else{
          self.mObserversOf_objectDisplay.triggerPacking ()
        }
      }
    }
  } */

  //····················································································································
  //   Observers of 'p1CanMove' transient property
  //····················································································································

  private final var mObserversOf_p1CanMove = EBWeakObserverSetRelay ()

  //····················································································································

  final func toMany_p1CanMove_StartsToBeObserved (by inObserver : EBObserverProtocol) {
    self.startsToBeObserved (by: inObserver)
    self.mObserversOf_p1CanMove.insert (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.p1CanMove_property.startsToBeObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  final func toMany_p1CanMove_StopsBeingObserved (by inObserver : EBObserverProtocol) {
    self.stopsBeingObserved (by: inObserver)
    self.mObserversOf_p1CanMove.remove (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.p1CanMove_property.stopsBeingObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  /* final private func addEBObserversOf_p1CanMove_toElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      for entry in self.mObserversOf_p1CanMove.values () {
        if let observer = entry.possibleObserver {
          managedObject.p1CanMove_property.startsToBeObserved (by: observer)
        }else{
          self.mObserversOf_p1CanMove.triggerPacking ()
        }
      }
    }
  } */

  //····················································································································

  /* final private func removeEBObserversOf_p1CanMove_fromElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      for entry in self.mObserversOf_p1CanMove.values () {
        if let observer = entry.possibleObserver {
          managedObject.p1CanMove_property.stopsBeingObserved (by: observer)
        }else{
          self.mObserversOf_p1CanMove.triggerPacking ()
        }
      }
    }
  } */

  //····················································································································
  //   Observers of 'p2CanMove' transient property
  //····················································································································

  private final var mObserversOf_p2CanMove = EBWeakObserverSetRelay ()

  //····················································································································

  final func toMany_p2CanMove_StartsToBeObserved (by inObserver : EBObserverProtocol) {
    self.startsToBeObserved (by: inObserver)
    self.mObserversOf_p2CanMove.insert (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.p2CanMove_property.startsToBeObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  final func toMany_p2CanMove_StopsBeingObserved (by inObserver : EBObserverProtocol) {
    self.stopsBeingObserved (by: inObserver)
    self.mObserversOf_p2CanMove.remove (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.p2CanMove_property.stopsBeingObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  /* final private func addEBObserversOf_p2CanMove_toElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      for entry in self.mObserversOf_p2CanMove.values () {
        if let observer = entry.possibleObserver {
          managedObject.p2CanMove_property.startsToBeObserved (by: observer)
        }else{
          self.mObserversOf_p2CanMove.triggerPacking ()
        }
      }
    }
  } */

  //····················································································································

  /* final private func removeEBObserversOf_p2CanMove_fromElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      for entry in self.mObserversOf_p2CanMove.values () {
        if let observer = entry.possibleObserver {
          managedObject.p2CanMove_property.stopsBeingObserved (by: observer)
        }else{
          self.mObserversOf_p2CanMove.triggerPacking ()
        }
      }
    }
  } */

  //····················································································································
  //   Observers of 'trackCanRotate' transient property
  //····················································································································

  private final var mObserversOf_trackCanRotate = EBWeakObserverSetRelay ()

  //····················································································································

  final func toMany_trackCanRotate_StartsToBeObserved (by inObserver : EBObserverProtocol) {
    self.startsToBeObserved (by: inObserver)
    self.mObserversOf_trackCanRotate.insert (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.trackCanRotate_property.startsToBeObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  final func toMany_trackCanRotate_StopsBeingObserved (by inObserver : EBObserverProtocol) {
    self.stopsBeingObserved (by: inObserver)
    self.mObserversOf_trackCanRotate.remove (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.trackCanRotate_property.stopsBeingObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  /* final private func addEBObserversOf_trackCanRotate_toElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      for entry in self.mObserversOf_trackCanRotate.values () {
        if let observer = entry.possibleObserver {
          managedObject.trackCanRotate_property.startsToBeObserved (by: observer)
        }else{
          self.mObserversOf_trackCanRotate.triggerPacking ()
        }
      }
    }
  } */

  //····················································································································

  /* final private func removeEBObserversOf_trackCanRotate_fromElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      for entry in self.mObserversOf_trackCanRotate.values () {
        if let observer = entry.possibleObserver {
          managedObject.trackCanRotate_property.stopsBeingObserved (by: observer)
        }else{
          self.mObserversOf_trackCanRotate.triggerPacking ()
        }
      }
    }
  } */

  //····················································································································
  //   Observers of 'selectionDisplay' transient property
  //····················································································································

  private final var mObserversOf_selectionDisplay = EBWeakObserverSetRelay ()

  //····················································································································

  final func toMany_selectionDisplay_StartsToBeObserved (by inObserver : EBObserverProtocol) {
    self.startsToBeObserved (by: inObserver)
    self.mObserversOf_selectionDisplay.insert (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.selectionDisplay_property.startsToBeObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  final func toMany_selectionDisplay_StopsBeingObserved (by inObserver : EBObserverProtocol) {
    self.stopsBeingObserved (by: inObserver)
    self.mObserversOf_selectionDisplay.remove (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.selectionDisplay_property.stopsBeingObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  /* final private func addEBObserversOf_selectionDisplay_toElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      for entry in self.mObserversOf_selectionDisplay.values () {
        if let observer = entry.possibleObserver {
          managedObject.selectionDisplay_property.startsToBeObserved (by: observer)
        }else{
          self.mObserversOf_selectionDisplay.triggerPacking ()
        }
      }
    }
  } */

  //····················································································································

  /* final private func removeEBObserversOf_selectionDisplay_fromElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      for entry in self.mObserversOf_selectionDisplay.values () {
        if let observer = entry.possibleObserver {
          managedObject.selectionDisplay_property.stopsBeingObserved (by: observer)
        }else{
          self.mObserversOf_selectionDisplay.triggerPacking ()
        }
      }
    }
  } */

  //····················································································································
  //   Observers of 'trackDirectionInDegrees' computed property
  //····················································································································

  private final var mObserversOf_trackDirectionInDegrees = EBWeakObserverSetRelay ()

  //····················································································································

  final func toMany_trackDirectionInDegrees_StartsToBeObserved (by inObserver : EBObserverProtocol) {
    self.startsToBeObserved (by: inObserver)
    self.mObserversOf_trackDirectionInDegrees.insert (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.trackDirectionInDegrees_property.startsToBeObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  final func toMany_trackDirectionInDegrees_StopsBeingObserved (by inObserver : EBObserverProtocol) {
    self.stopsBeingObserved (by: inObserver)
    self.mObserversOf_trackDirectionInDegrees.remove (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.trackDirectionInDegrees_property.stopsBeingObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  /* final private func addEBObserversOf_trackDirectionInDegrees_toElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      for entry in self.mObserversOf_trackDirectionInDegrees.values () {
        if let observer = entry.possibleObserver {
          managedObject.trackDirectionInDegrees_property.startsToBeObserved (by: observer)
        }else{
          self.mObserversOf_trackDirectionInDegrees.triggerPacking ()
        }
      }
    }
  } */

  //····················································································································

  /* final private func removeEBObserversOf_trackDirectionInDegrees_fromElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      for entry in self.mObserversOf_trackDirectionInDegrees.values () {
        if let observer = entry.possibleObserver {
          managedObject.trackDirectionInDegrees_property.stopsBeingObserved (by: observer)
        }else{
          self.mObserversOf_trackDirectionInDegrees.triggerPacking ()
        }
      }
    }
  } */

  //····················································································································
  //   Observers of 'computedP1X' computed property
  //····················································································································

  private final var mObserversOf_computedP1X = EBWeakObserverSetRelay ()

  //····················································································································

  final func toMany_computedP1X_StartsToBeObserved (by inObserver : EBObserverProtocol) {
    self.startsToBeObserved (by: inObserver)
    self.mObserversOf_computedP1X.insert (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.computedP1X_property.startsToBeObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  final func toMany_computedP1X_StopsBeingObserved (by inObserver : EBObserverProtocol) {
    self.stopsBeingObserved (by: inObserver)
    self.mObserversOf_computedP1X.remove (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.computedP1X_property.stopsBeingObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  /* final private func addEBObserversOf_computedP1X_toElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      for entry in self.mObserversOf_computedP1X.values () {
        if let observer = entry.possibleObserver {
          managedObject.computedP1X_property.startsToBeObserved (by: observer)
        }else{
          self.mObserversOf_computedP1X.triggerPacking ()
        }
      }
    }
  } */

  //····················································································································

  /* final private func removeEBObserversOf_computedP1X_fromElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      for entry in self.mObserversOf_computedP1X.values () {
        if let observer = entry.possibleObserver {
          managedObject.computedP1X_property.stopsBeingObserved (by: observer)
        }else{
          self.mObserversOf_computedP1X.triggerPacking ()
        }
      }
    }
  } */

  //····················································································································
  //   Observers of 'computedP1Y' computed property
  //····················································································································

  private final var mObserversOf_computedP1Y = EBWeakObserverSetRelay ()

  //····················································································································

  final func toMany_computedP1Y_StartsToBeObserved (by inObserver : EBObserverProtocol) {
    self.startsToBeObserved (by: inObserver)
    self.mObserversOf_computedP1Y.insert (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.computedP1Y_property.startsToBeObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  final func toMany_computedP1Y_StopsBeingObserved (by inObserver : EBObserverProtocol) {
    self.stopsBeingObserved (by: inObserver)
    self.mObserversOf_computedP1Y.remove (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.computedP1Y_property.stopsBeingObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  /* final private func addEBObserversOf_computedP1Y_toElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      for entry in self.mObserversOf_computedP1Y.values () {
        if let observer = entry.possibleObserver {
          managedObject.computedP1Y_property.startsToBeObserved (by: observer)
        }else{
          self.mObserversOf_computedP1Y.triggerPacking ()
        }
      }
    }
  } */

  //····················································································································

  /* final private func removeEBObserversOf_computedP1Y_fromElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      for entry in self.mObserversOf_computedP1Y.values () {
        if let observer = entry.possibleObserver {
          managedObject.computedP1Y_property.stopsBeingObserved (by: observer)
        }else{
          self.mObserversOf_computedP1Y.triggerPacking ()
        }
      }
    }
  } */

  //····················································································································
  //   Observers of 'computedP2X' computed property
  //····················································································································

  private final var mObserversOf_computedP2X = EBWeakObserverSetRelay ()

  //····················································································································

  final func toMany_computedP2X_StartsToBeObserved (by inObserver : EBObserverProtocol) {
    self.startsToBeObserved (by: inObserver)
    self.mObserversOf_computedP2X.insert (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.computedP2X_property.startsToBeObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  final func toMany_computedP2X_StopsBeingObserved (by inObserver : EBObserverProtocol) {
    self.stopsBeingObserved (by: inObserver)
    self.mObserversOf_computedP2X.remove (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.computedP2X_property.stopsBeingObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  /* final private func addEBObserversOf_computedP2X_toElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      for entry in self.mObserversOf_computedP2X.values () {
        if let observer = entry.possibleObserver {
          managedObject.computedP2X_property.startsToBeObserved (by: observer)
        }else{
          self.mObserversOf_computedP2X.triggerPacking ()
        }
      }
    }
  } */

  //····················································································································

  /* final private func removeEBObserversOf_computedP2X_fromElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      for entry in self.mObserversOf_computedP2X.values () {
        if let observer = entry.possibleObserver {
          managedObject.computedP2X_property.stopsBeingObserved (by: observer)
        }else{
          self.mObserversOf_computedP2X.triggerPacking ()
        }
      }
    }
  } */

  //····················································································································
  //   Observers of 'computedP2Y' computed property
  //····················································································································

  private final var mObserversOf_computedP2Y = EBWeakObserverSetRelay ()

  //····················································································································

  final func toMany_computedP2Y_StartsToBeObserved (by inObserver : EBObserverProtocol) {
    self.startsToBeObserved (by: inObserver)
    self.mObserversOf_computedP2Y.insert (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.computedP2Y_property.startsToBeObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  final func toMany_computedP2Y_StopsBeingObserved (by inObserver : EBObserverProtocol) {
    self.stopsBeingObserved (by: inObserver)
    self.mObserversOf_computedP2Y.remove (inObserver)
    /* switch self.selection {
    case .empty, .multiple :
      break
    case .single (let v) :
      for managedObject in v {
        managedObject.computedP2Y_property.stopsBeingObserved (by: inObserver)
      }
    } */
  }

  //····················································································································

  /* final private func addEBObserversOf_computedP2Y_toElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      for entry in self.mObserversOf_computedP2Y.values () {
        if let observer = entry.possibleObserver {
          managedObject.computedP2Y_property.startsToBeObserved (by: observer)
        }else{
          self.mObserversOf_computedP2Y.triggerPacking ()
        }
      }
    }
  } */

  //····················································································································

  /* final private func removeEBObserversOf_computedP2Y_fromElementsOfSet (_ inSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inSet.values {
      for entry in self.mObserversOf_computedP2Y.values () {
        if let observer = entry.possibleObserver {
          managedObject.computedP2Y_property.stopsBeingObserved (by: observer)
        }else{
          self.mObserversOf_computedP2Y.triggerPacking ()
        }
      }
    }
  } */

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    TransientArrayOf BoardTrack
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

// TransientArrayOf_BoardTrack is useless.

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    TransientArrayOfSuperOf BoardTrack
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

final class TransientArrayOfSuperOf_BoardTrack <SUPER : EBManagedObject> : ReadOnlyArrayOf_BoardTrack {

  //····················································································································
  //   Data provider
  //····················································································································

  private weak var mDataProvider : ReadOnlyAbstractArrayProperty <SUPER>? = nil // SHOULD BE WEAK
  private var mTransientKind : PropertyKind = .empty
  private var mModelArrayShouldBeComputed = true
  private var mModelEvent = EBModelEvent ()

  //····················································································································

  override init () {
    super.init ()
    self.mModelEvent.mEventCallBack = { [weak self] in self?.computeModelArray () }
  }

  //····················································································································

  func setDataProvider (_ inProvider : ReadOnlyAbstractArrayProperty <SUPER>?) {
    if self.mDataProvider !== inProvider {
      self.mDataProvider?.detachClient (self)
      self.mDataProvider = inProvider
      self.mDataProvider?.attachClient (self)
    }
  }

  //····················································································································

  override func notifyModelDidChange () {
    self.mModelEvent.observedObjectDidChange ()
    self.mModelArrayShouldBeComputed = true
    super.notifyModelDidChange ()
  }

  //····················································································································

  private final func computeModelArray () {
    if self.mModelArrayShouldBeComputed {
      self.mModelArrayShouldBeComputed = false
      var newModelArray : EBReferenceArray <SUPER>
      if let dataProvider = self.mDataProvider {
        switch dataProvider.selection {
        case .empty :
          newModelArray = EBReferenceArray ()
          self.mTransientKind = .empty
        case .single (let v) :
          newModelArray = EBReferenceArray (v)
          self.mTransientKind = .single
         case .multiple :
          newModelArray = EBReferenceArray ()
          self.mTransientKind = .multiple
        }
      }else{
        newModelArray = EBReferenceArray ()
        self.mTransientKind = .empty
      }
      var newArray = EBReferenceArray <BoardTrack> ()
      for superObject in newModelArray.values {
        if let object = superObject as? BoardTrack {
          newArray.append (object)
        }
      }
      self.mInternalArrayValue = newArray
    }
  }

  //····················································································································

  override var selection : EBSelection < [BoardTrack] > {
    self.computeModelArray ()
    switch self.mTransientKind {
    case .empty :
      return .empty
    case .single :
      return .single (self.mInternalArrayValue.values)
    case .multiple :
      return .multiple
    }
  }

  //····················································································································

  override var propval : EBReferenceArray <BoardTrack> {
    self.computeModelArray ()
    return self.mInternalArrayValue
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    To many relationship read write: BoardTrack
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class ReadWriteArrayOf_BoardTrack : ReadOnlyArrayOf_BoardTrack {

  //····················································································································

  func setProp (_ value :  EBReferenceArray <BoardTrack>) { } // Abstract method

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    Proxy: ProxyArrayOf_BoardTrack
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

// ProxyArrayOf_BoardTrack is useless.

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    Stored Array: BoardTrack
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class StoredArrayOf_BoardTrack : ReadWriteArrayOf_BoardTrack, EBSignatureObserverProtocol, DocumentStorablePropertyProtocol {

  //····················································································································

  init (usedForSignature inUsedForSignature : Bool, key inKey : String?) {
    self.mUsedForSignature = inUsedForSignature
    self.mKey = inKey
    super.init ()
  }

  //····················································································································
  
  private final let mKey : String?
  final var key : String? { return self.mKey }
  
  //····················································································································

  func initialize (fromDictionary inDictionary : [String : Any],
                   managedObjectArray inManagedObjectArray : [EBManagedObject]) {
    if let key = self.mKey, let objectSavingIndexArray = inDictionary [key] as? [Int] {
      var objectArray = EBReferenceArray <BoardTrack> ()
      for idx in objectSavingIndexArray {
        objectArray.append (inManagedObjectArray [idx] as! BoardTrack)
      }
      self.setProp (objectArray)
    }
  }

  //····················································································································

  func initialize (fromRange inRange : NSRange, ofData inData : Data, _ inRawObjectArray : [RawObject]) {
    if inRange.length > 0 {
      var objectArray = EBReferenceArray <BoardTrack> ()
      let indexArray = inData.base62EncodedIntArray (fromRange: inRange)
      for idx in indexArray {
        objectArray.append (inRawObjectArray [idx].object as! BoardTrack)
      }
      self.setProp (objectArray)
    }
  }

  //····················································································································

  func store (inDictionary ioDictionary : inout [String : Any]) {
    if let key = self.mKey, self.mInternalArrayValue.count > 0 {
      var array = [Int] ()
      for object in self.mInternalArrayValue.values {
        array.append (object.savingIndex)
      }
      ioDictionary [key] = array
    }
  }

  //····················································································································

  func enterRelationshipObjects (intoArray ioArray : inout [EBManagedObject]) {
    if self.mKey != nil, self.mInternalArrayValue.count > 0 {
      for object in self.mInternalArrayValue.values {
        ioArray.append (object)
      }
    }
  }

  //····················································································································

  func appendValueTo (data ioData : inout Data) {
    enterToManyRelationshipObjectIndexes (from: self.propval.values, into: &ioData)
  }

  //····················································································································
  //   Signature ?
  //····················································································································

  final private let mUsedForSignature : Bool

  //····················································································································
  //   Undo manager
  //····················································································································

  weak final var undoManager : UndoManager? = nil // SOULD BE WEAK

  //····················································································································
  //   Opposite relationship management
  //····················································································································

  private final var mSetOppositeRelationship : Optional < (_ inManagedObject : BoardTrack) -> Void > = nil
  private final var mResetOppositeRelationship : Optional < (_ inManagedObject : BoardTrack) -> Void > = nil

  //····················································································································

  final func setOppositeRelationShipFunctions (setter inSetter : @escaping (_ inManagedObject : BoardTrack) -> Void,
                                               resetter inResetter : @escaping (_ inManagedObject : BoardTrack) -> Void) {
    self.mSetOppositeRelationship = inSetter
    self.mResetOppositeRelationship = inResetter
  }

  //····················································································································
  // Model will change
  //····················································································································

  override func notifyModelDidChangeFrom (oldValue inOldValue : EBReferenceArray <BoardTrack>) {
  //--- Register old value in undo manager
    self.undoManager?.registerUndo (withTarget: self) { $0.mInternalArrayValue = inOldValue }
  //---
    super.notifyModelDidChangeFrom (oldValue: inOldValue)
  }

  //····················································································································
  // Model did change
  //····················································································································

  override func notifyModelDidChange () {
  //--- Notify observers
    self.observedObjectDidChange ()
  //---
    super.notifyModelDidChange ()
  }

  //····················································································································
  // Update observers
  //····················································································································

  override func updateObservers (removedSet inRemovedSet : EBReferenceSet <BoardTrack>,
                                 addedSet inAddedSet : EBReferenceSet <BoardTrack>) {
    for managedObject in inRemovedSet.values {
      if self.mUsedForSignature {
        managedObject.setSignatureObserver (observer: nil)
      }
      self.mResetOppositeRelationship? (managedObject)
   }
  //---
    for managedObject in inAddedSet.values {
      if self.mUsedForSignature {
        managedObject.setSignatureObserver (observer: self)
      }
      self.mSetOppositeRelationship? (managedObject)
    }
  //---
    super.updateObservers (removedSet: inRemovedSet, addedSet: inAddedSet)
 }

  //····················································································································

  override final var selection : EBSelection < [BoardTrack] > { return .single (self.mInternalArrayValue.values) }

  //····················································································································

  override func setProp (_ inValue : EBReferenceArray <BoardTrack>) { self.mInternalArrayValue = inValue }

  //····················································································································

  override final var propval : EBReferenceArray <BoardTrack> { return self.mInternalArrayValue }

  //····················································································································

  final func remove (_ object : BoardTrack) {
    if let idx = self.mInternalArrayValue.firstIndex (of: object) {
      self.mInternalArrayValue.remove (at: idx)
    }
  }

  //····················································································································

  final func add (_ object : BoardTrack) {
    if !self.internalSetValue.contains (object) {
      self.mInternalArrayValue.append (object)
    }
  }

  //····················································································································
  //   signature
  //····················································································································

  private weak final var mSignatureObserver : EBSignatureObserverProtocol? = nil // SOULD BE WEAK

  //····················································································································

  private final var mSignatureCache : UInt32? = nil

  //····················································································································

  final func setSignatureObserver (observer : EBSignatureObserverProtocol?) {
    self.mSignatureObserver?.clearSignatureCache ()
    self.mSignatureObserver = observer
    observer?.clearSignatureCache ()
    self.clearSignatureCache ()
 }

  //····················································································································

  final func signature () -> UInt32 {
    let computedSignature : UInt32
    if let s = self.mSignatureCache {
      computedSignature = s
    }else{
      computedSignature = self.computeSignature ()
      self.mSignatureCache = computedSignature
    }
    return computedSignature
  }

  //····················································································································

  final private func computeSignature () -> UInt32 {
    var crc : UInt32 = 0
    for object in self.mInternalArrayValue.values {
      crc.accumulate (u32: object.signature ())
    }
    return crc
  }

  //····················································································································

  final func clearSignatureCache () {
    if self.mSignatureCache != nil {
      self.mSignatureCache = nil
      self.mSignatureObserver?.clearSignatureCache ()
    }
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    Preferences array: BoardTrack
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

// PreferencesArrayOf_BoardTrack is useless.

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

