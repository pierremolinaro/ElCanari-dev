//——————————————————————————————————————————————————————————————————————————————————————————————————
//  THIS FILE IS GENERATED BY EASY BINDINGS, DO NOT MODIFY IT
//——————————————————————————————————————————————————————————————————————————————————————————————————

import AppKit

//——————————————————————————————————————————————————————————————————————————————————————————————————

private let XY_WINDOW_MARGIN : CGFloat = 5.0
private let XY_WINDOW_BACKGROUND_COLOR = NSColor.black
private let XY_WINDOW_TEXT_COLOR = NSColor.white
let DEFAULT_HELPER_TEXT = "" // SHIFT, CONTROL, OPTION and COMMAND modifier keys helper text"

//——————————————————————————————————————————————————————————————————————————————————————————————————

extension EBGraphicView {

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  final func performZoomToFit () {
    self.mZoomPropertyCache = 0 // Means zoom to fit
    self.applyZoom ()
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  final func set (zoom inNewZoom : Int) {
    self.mZoomPropertyCache = inNewZoom
    self.applyZoom ()
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  final private func buildXYHelperWindow () -> NSWindow {
    let window = NSWindow (contentRect: .zero, styleMask: .borderless, backing: .buffered, defer: false)
    window.backgroundColor = NSColor.clear
    window.isOpaque = false
    window.isExcludedFromWindowsMenu = true
    window.orderFront (nil)
    let view = EBHelperViewWithBackground (frame: .zero)
    window.contentView = view
  //--- X
    let xPlacard = NSTextField (frame: .zero)
    xPlacard.isBezeled = false
    xPlacard.isBordered = false
    xPlacard.drawsBackground = true
    xPlacard.textColor = XY_WINDOW_TEXT_COLOR
    xPlacard.backgroundColor = XY_WINDOW_BACKGROUND_COLOR
    xPlacard.isEnabled = true
    xPlacard.isEditable = false
    xPlacard.font = NSFont.systemFont (ofSize: NSFont.smallSystemFontSize)
    view.addSubview (xPlacard)
  //--- Y
    let yPlacard = NSTextField (frame: .zero)
    yPlacard.isBezeled = false
    yPlacard.isBordered = false
    yPlacard.drawsBackground = true
    yPlacard.textColor = XY_WINDOW_TEXT_COLOR
    yPlacard.backgroundColor = XY_WINDOW_BACKGROUND_COLOR
    yPlacard.isEnabled = true
    yPlacard.isEditable = false
    yPlacard.font = NSFont.systemFont (ofSize: NSFont.smallSystemFontSize)
    view.addSubview (yPlacard)
  //---
    return window
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  final func updateXYHelperWindow (mouseLocationInView inLocationInView : NSPoint) {
    let commandKey = NSEvent.modifierFlags.contains (.command)
    if commandKey, let myWindow = self.window, self.visibleRect.contains (inLocationInView) {
      let xyWindow : NSWindow
      if let window = self.mXYwindow {
        xyWindow = window
      }else{
        xyWindow = buildXYHelperWindow ()
        self.mXYwindow = xyWindow
      }
      if let view = xyWindow.contentView,
         view.subviews.count == 2,
         let placardX = view.subviews [0] as? NSTextField,
         let placardY = view.subviews [1] as? NSTextField {
        placardX.stringValue = "X = " + valueAndUnitStringFrom (valueInCocoaUnit: inLocationInView.x, displayUnit: self.mXPlacardUnit)
        placardY.stringValue = "Y = " + valueAndUnitStringFrom (valueInCocoaUnit: inLocationInView.y, displayUnit: self.mYPlacardUnit)
        placardX.sizeToFit ()
        placardY.sizeToFit ()
        let w = max (placardX.frame.size.width, placardY.frame.size.width)
        placardY.frame.origin.x = XY_WINDOW_MARGIN
        placardY.frame.origin.y = XY_WINDOW_MARGIN
        placardY.frame.size.width = w
        placardX.frame.size.width = w
        placardX.frame.origin.x = XY_WINDOW_MARGIN
        placardX.frame.origin.y = placardY.frame.maxY
        let s = NSSize (width: w + XY_WINDOW_MARGIN * 2.0, height: placardX.frame.maxY + XY_WINDOW_MARGIN)
        view.frame.size = s
        let locationInWindow = self.convert (inLocationInView, to: nil)
        let rScreen = myWindow.convertToScreen (NSRect (origin: locationInWindow, size: NSSize ()))
        var frameOrigin = rScreen.origin
        frameOrigin.x -= view.frame.size.width + canariUnitToCocoa (self.mGridStepInCanariUnit) * self.actualScale + 5.0
        frameOrigin.y -= view.frame.size.height / 2.0
        xyWindow.setFrameOrigin (frameOrigin)
        xyWindow.setContentSize (s)
      }else{
        self.removeXYHelperWindow ()
      }
    }else{
      self.removeXYHelperWindow ()
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  final func removeXYHelperWindow () {
    self.mXYwindow?.orderOut (nil)
    self.mXYwindow = nil
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // Live scrolling notification is used for updating XY placards
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  final func installLiveScrollingNotification () {
    if let scrollView = self.enclosingScrollView {
      let nc = NotificationCenter.default
      nc.addObserver (
        self,
        selector: #selector (EBGraphicView.performLiveScrolling(_:)),
        name: NSScrollView.didLiveScrollNotification,
        object: scrollView
      )
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  @objc final private func performLiveScrolling (_ _ : Notification) {
    if let myWindow = self.window {
      let mouseLocationInScreen = NSEvent.mouseLocation
    //--- Note: NSWindow.convertPoint (fromScreen:) is available from 10.12
    //   So we use NSWindow.convertFromScreen for NSRect (available from 10.7)
      let rectInScreen = NSRect (origin: mouseLocationInScreen, size: NSSize ())
      let rectInWindow = myWindow.convertFromScreen (rectInScreen)
      let mouseLocationInView = self.convert (rectInWindow.origin, from: nil)
      let locationOnGridInView = mouseLocationInView.aligned (onGrid: canariUnitToCocoa (self.mArrowKeyMagnitude))
      self.updateXYHelperWindow (mouseLocationInView: locationOnGridInView)
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  final func defaultHelperString (with inUnalignedMouseLocationInView : NSPoint, _ inModifierFlags : NSEvent.ModifierFlags) -> String {
    let modifierFlagsContainsControl = inModifierFlags.contains (.control)
    let modifierFlagsContainsShift = inModifierFlags.contains (.shift)
    let modifierFlagsContainsOption = inModifierFlags.contains (.option)
    let (possibleObjectIndex, _) = self.indexOfFrontObject (at: inUnalignedMouseLocationInView)
    var helperString = DEFAULT_HELPER_TEXT
    switch (modifierFlagsContainsControl, modifierFlagsContainsShift, modifierFlagsContainsOption) {
    case (true, true, false) : // Ctrl Key On, shift, no option -> Zoom region
      helperString = "CONTROL + SHIFT: mouse down starts a zoom region"
    case (true, false, false) : // Ctrl Key On, no shift -> Contextual click
      if let _ = self.mContextualMenuBuilder? (inUnalignedMouseLocationInView.canariPoint) {
        helperString = "CONTROL: mouse down shows a contextual menu"
      }
    case (false, true, false) : // Shift Key
      helperString = "SHIFT: mouse down complements selection of objects intersecting selection rectangle"
    case (_, _, true) : // Option Key On
      if let _ = self.mPasteboardType {
        helperString = "OPTION: mouse down starts duplication of selected objects"
      }else if let s = self.mHelperStringForOptionModifier {
        helperString = s
      }
    case (false, false, false) : // No Modifier Key
      if let objectIndex = possibleObjectIndex {
       if self.objectWithIndexIsSelected (objectIndex) {
         helperString = "Mouse down inside a selected object starts a drag operation"
       }else{
         helperString = "Mouse down inside an unselected object selects it"
       }
      }else{
        helperString = "Mouse down outside any object starts a selection rectangle"
      }
    }
    if inModifierFlags.contains (.command) {
      if !helperString.isEmpty {
        helperString += ", "
      }
      helperString += "COMMAND: displays XY location"
    }
    return helperString
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

}

//——————————————————————————————————————————————————————————————————————————————————————————————————
//   EBHelperViewWithBackground
//——————————————————————————————————————————————————————————————————————————————————————————————————

private final class EBHelperViewWithBackground : NSView {

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override func draw (_ inDirtyRect : NSRect) {
    var bp = NSBezierPath (roundedRect: self.bounds, xRadius: XY_WINDOW_MARGIN, yRadius: XY_WINDOW_MARGIN)
    XY_WINDOW_BACKGROUND_COLOR.setFill ()
    bp.fill ()
    bp = NSBezierPath (roundedRect: self.bounds.insetBy (dx: 0.5, dy: 0.5), xRadius: XY_WINDOW_MARGIN, yRadius: XY_WINDOW_MARGIN)
    bp.lineWidth = 1.0
    XY_WINDOW_TEXT_COLOR.setStroke ()
    bp.stroke ()
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override var isOpaque : Bool { return false }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

}

//——————————————————————————————————————————————————————————————————————————————————————————————————
