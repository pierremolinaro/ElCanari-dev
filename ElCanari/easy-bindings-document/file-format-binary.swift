//--------------------------------------------------------------------------------------------------
//  THIS FILE IS GENERATED BY EASY BINDINGS, DO NOT MODIFY IT
//--------------------------------------------------------------------------------------------------

import AppKit

//--------------------------------------------------------------------------------------------------

@MainActor func loadEasyBindingBinaryFile (_ inUndoManager : UndoManager?,
                                           documentName inDocumentName : String,
                                           from ioDataScanner: inout EBDataScanner) -> EBDocumentReadData {
  setStartOperationDateToNow ("Read Binary Document file: \(inDocumentName)")
  do{
    var operationStartDate = Date ()
    let startDate = operationStartDate
  //--- Read Status
    let metadataStatus = ioDataScanner.parseByte ()
  //--- if ok, check byte is 1
    ioDataScanner.acceptRequired (byte: 1)
  //--- Read metadata dictionary
    let dictionaryData = ioDataScanner.parseAutosizedData ()
    let metadataDictionary = try PropertyListSerialization.propertyList (from: dictionaryData as Data,
      options: [],
      format: nil
    ) as! [String : Any]
  //--- Read data
    let dataFormat = ioDataScanner.parseByte ()
    let fileData = ioDataScanner.parseAutosizedData ()
    appendDocumentFileOperationInfo ("  Read file: \(Int (Date ().timeIntervalSince (operationStartDate) * 1000.0)) ms")
    operationStartDate = Date ()
  //--- if ok, check final byte (0)
    ioDataScanner.acceptRequired (byte: 0)
  //--- Scanner error ?
    if !ioDataScanner.ok () {
      let dictionary = [
        "Cannot Open Document" : NSLocalizedDescriptionKey,
        "The file has an invalid format" : NSLocalizedRecoverySuggestionErrorKey
      ]
      throw NSError (domain: Bundle.main.bundleIdentifier!, code: 1, userInfo: dictionary)
    }
  //--- Analyze read data
    var rootObject : EBManagedObject? = nil
    if dataFormat == 0x06 {
      rootObject = try readManagedObjectsFromBinaryData (inUndoManager, inData: fileData)
    }else{
      try raiseInvalidDataFormatError (dataFormat: dataFormat)
    }
    appendDocumentFileOperationInfo ("  Analyze read data: \(Int (Date ().timeIntervalSince (operationStartDate) * 1000.0)) ms")
    operationStartDate = Date ()
  //---
    if rootObject == nil {
      let dictionary = [
        "Cannot Open Document" :  NSLocalizedDescriptionKey,
        "Root object cannot be read" :  NSLocalizedRecoverySuggestionErrorKey
      ]
      throw NSError (domain: Bundle.main.bundleIdentifier!, code: 1, userInfo: dictionary)
    }
  //---
    appendDocumentFileOperationInfo ("Total duration: \(Int (Date ().timeIntervalSince (startDate) * 1000.0)) ms")
    let documentData = EBDocumentData (
      documentMetadataStatus: metadataStatus,
      documentMetadataDictionary: metadataDictionary,
      documentRootObject: rootObject!,
      documentFileFormat: .binary
    )
    return .ok (documentData: documentData)
  }catch{
    return .readError (error: error)
  }
}

//--------------------------------------------------------------------------------------------------

private func raiseInvalidDataFormatError (dataFormat : UInt8) throws {
  let dictionary = [
    "Cannot Open Document" :  NSLocalizedDescriptionKey,
    "Unkown data format: \(dataFormat)" :  NSLocalizedRecoverySuggestionErrorKey
  ]
  throw NSError (domain: Bundle.main.bundleIdentifier!, code: 1, userInfo: dictionary)
}

//--------------------------------------------------------------------------------------------------

@MainActor fileprivate func readManagedObjectsFromBinaryData (_ inUndoManager : UndoManager?, inData : Data) throws -> EBManagedObject? {
  var resultRootObject : EBManagedObject? = nil
  if let dictionaryArray = try PropertyListSerialization.propertyList (from: inData as Data, options: [], format: nil) as? [[String : Any]] {
    var objectArray = [EBManagedObject] ()
    for d in dictionaryArray {
      let className = d [ENTITY_KEY] as! String
      let object = newInstanceOfEntityNamed (inUndoManager, className)
      objectArray.append (object)
    }
    var idx = 0
    for d in dictionaryArray {
      let object = objectArray [idx]
      object.setUpProperties (fromValueDictionary: d, managedObjectArray: objectArray)
      idx += 1
    }
    resultRootObject = objectArray [0] // Set root object
  }
  return resultRootObject
}

//--------------------------------------------------------------------------------------------------

@MainActor func dataForBinarySaveOperation (from inDocumentData : EBDocumentData) throws -> Data {
  // let start = Date ()
  var fileBinaryData = Data ()
//--- Append signature
  fileBinaryData.appendBinarySignature ()
//--- Write status
  fileBinaryData.append (inDocumentData.documentMetadataStatus)
//--- Append metadata dictionary
  let metaData = try PropertyListSerialization.data (fromPropertyList: inDocumentData.documentMetadataDictionary, format: .binary, options: 0)
  fileBinaryData.append (1)
  fileBinaryData.appendAutosizedData (metaData)
//--- Append document data
  let reachableObjectArray = collectAndPrepareObjectsForSaveOperation (fromRoot: inDocumentData.documentRootObject)
  var saveDataArray : [[String : Any]] = []
  for object in reachableObjectArray {
    var d = [String : Any] ()
    object.savePropertiesAndRelationshipsIntoDictionary (&d)
    saveDataArray.append (d)
  }
  let documentData = try PropertyListSerialization.data (fromPropertyList: saveDataArray, format: .binary, options: 0)
  fileBinaryData.append (6)
  fileBinaryData.appendAutosizedData (documentData)
//--- Append final byte
  fileBinaryData.append (0)
//---
  // Swift.print ("Binary Saving \(Int (Date ().timeIntervalSince (start) * 1000.0)) ms")
  return fileBinaryData
}

//--------------------------------------------------------------------------------------------------
