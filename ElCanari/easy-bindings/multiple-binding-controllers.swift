//--------------------------------------------------------------------------------------------------
//  THIS FILE IS GENERATED BY EASY BINDINGS, DO NOT MODIFY IT
//--------------------------------------------------------------------------------------------------

import AppKit

//--------------------------------------------------------------------------------------------------

@MainActor protocol HiddenEBProtocol : AnyObject {
  var isHidden : Bool { get set }
}

//--------------------------------------------------------------------------------------------------

extension NSView : HiddenEBProtocol {
}

//--------------------------------------------------------------------------------------------------

enum MultipleBindingBooleanOperation {
  case or
  case and
  case xor
}

//--------------------------------------------------------------------------------------------------

enum MultipleBindingIntegerOperation {
  case eq
  case ne
  case lt
  case le
  case gt
  case ge
}

//--------------------------------------------------------------------------------------------------

@MainActor indirect enum EBMultipleBindingBooleanExpression {

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  case alwaysTrue
  case boolcmp (EBMultipleBindingBooleanExpression, MultipleBindingBooleanOperation, EBMultipleBindingBooleanExpression)
  case intcmp  (EBMultipleBindingIntegerExpression, MultipleBindingIntegerOperation, EBMultipleBindingIntegerExpression)
  case not  (EBMultipleBindingBooleanExpression)
  case prop (EBObservableProperty <Bool>)

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  func addModelsTo (_ ioModelArray : inout [any EBObservableObjectProtocol]) {
    switch self {
    case .alwaysTrue :
      ()
    case .boolcmp (let left, _, let right) :
      left.addModelsTo (&ioModelArray)
      right.addModelsTo (&ioModelArray)
    case .intcmp (let left, _, let right) :
      left.addModelsTo (&ioModelArray)
      right.addModelsTo (&ioModelArray)
    case .not (let bindingExp) :
      bindingExp.addModelsTo (&ioModelArray)
    case .prop  (let model) :
      ioModelArray.append (model)
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  func compute () -> EBSelection <Bool> {
    switch self {
    case .alwaysTrue :
      return .single (true)
    case .boolcmp (let left, let op, let right) :
      let leftSelection = left.compute ()
      let rightSelection = right.compute ()
      switch (leftSelection, rightSelection) {
      case (.empty, _), (_, .empty) :
        return .empty
      case (_, .multiple), (.multiple, _) :
        return .multiple
      case (.single (let v), .single (let w)) :
        switch op {
        case .and :
          return .single (v && w)
        case .or :
          return .single (v || w)
        case .xor :
          return .single (v != w)
        }
      }
    case .intcmp (let left, let op, let right) :
      let leftSelection = left.compute ()
      let rightSelection = right.compute ()
      switch (leftSelection, rightSelection) {
      case (.empty, _), (_, .empty) :
        return .empty
      case (_, .multiple), (.multiple, _) :
        return .multiple
      case (.single (let v), .single (let w)) :
        switch op {
        case .eq :
          return .single (v == w)
        case .ne :
          return .single (v != w)
        case .lt :
          return .single (v < w)
        case .le :
          return .single (v <= w)
        case .gt :
          return .single (v > w)
        case .ge :
          return .single (v >= w)
        }
      }
    case .not (let bindingExp) :
      let selection = bindingExp.compute ()
      switch selection {
      case .empty :
        return .empty
      case .single (let v) :
        return .single (!v)
      case .multiple :
        return .multiple
      }
    case .prop  (let model) :
      return model.selection
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

}

//--------------------------------------------------------------------------------------------------

@MainActor enum EBMultipleBindingIntegerExpression {

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  case literalInt (Int)
  case prop (EBObservableProperty <Int>)

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  func addModelsTo (_ ioModelArray : inout [any EBObservableObjectProtocol]) {
    switch self {
    case .literalInt :
      ()
    case .prop (let model) :
      ioModelArray.append (model)
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  func compute () -> EBSelection <Int> {
    switch self {
    case .literalInt (let v) :
      return .single (v)
    case .prop (let model) :
      return model.selection
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

}

//--------------------------------------------------------------------------------------------------
