//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  THIS FILE IS GENERATED BY EASY BINDINGS, DO NOT MODIFY IT
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

import Cocoa

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct RawObject {
  let index : Int
  let object : EBManagedObject
  let propertyDictionary : [String : NSRange]
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

@MainActor func loadEasyBindingTextFile (_ inUndoManager : EBUndoManager?,
                                         documentName inDocumentName : String,
                                         from ioDataScanner: inout EBDataScanner) throws -> EBDocumentData {
  setStartOperationDateToNow ("Read Text Document file: \(inDocumentName)")
//--- Check header ends with line feed
  ioDataScanner.acceptRequired (byte: ASCII.lineFeed.rawValue)
//--- Read Status
  let metadataStatus = UInt8 (ioDataScanner.parseBase62EncodedInt ())
 // Swift.print ("metadataStatus \(metadataStatus)")
//--- Read metadata dictionary
  let metadataDictionary : [String : Any] = try ioDataScanner.parseJSON ()
 // Swift.print ("metadataDictionary \(metadataDictionary)")
//--- Read classes
  var classDefinition = [(String, [String])] ()
  while ioDataScanner.testAccept (byte: ASCII.dollar.rawValue) {
    let className = try ioDataScanner.parseString ()
    var readPropertyNames = true
    var propertyNameArray = [String] ()
    while readPropertyNames, ioDataScanner.ok () {
      if ioDataScanner.test (byte: ASCII.dollar.rawValue) {
        readPropertyNames = false
      }else if ioDataScanner.test (byte: ASCII.at.rawValue) {
        readPropertyNames = false
      }else{
        let propertyName = try ioDataScanner.parseString ()
        propertyNameArray.append (propertyName)
      }
    }
    classDefinition.append ((className, propertyNameArray))
  }
  appendDocumentFileOperationInfo ("read \(classDefinition.count) classes done")
//--- Read objects
//  let operationQueue = OperationQueue ()
//  let mutex = DispatchSemaphore (value: 1)
  var rawObjectArray = [RawObject] ()
  var idx = 0
  let data = ioDataScanner.data
  while !ioDataScanner.eof (), ioDataScanner.testAccept (byte: ASCII.at.rawValue) {
    let index = idx
    idx += 1
    let classIndex = ioDataScanner.parseBase62EncodedInt ()
    let propertyNameArray = classDefinition [classIndex].1
    var propertyValueDictionary = [String : NSRange] ()
    propertyValueDictionary.reserveCapacity (propertyNameArray.count)
    for propertyName in propertyNameArray {
      let propertyRange = ioDataScanner.getLineRangeAndAdvance ()
      propertyValueDictionary [propertyName] = propertyRange
    }
    let className = classDefinition [classIndex].0
//    operationQueue.addOperation {
      let managedObject = newInstanceOfEntityNamed (inUndoManager, className)!
      managedObject.setUpPropertiesWithTextDictionary (propertyValueDictionary, data)
      let rawObject = RawObject (index: index, object: managedObject, propertyDictionary: propertyValueDictionary)
//      mutex.wait ()
      rawObjectArray.append (rawObject)
//      mutex.signal ()
//    }
  }
//  let pendingOperationCount = operationQueue.operationCount
//  operationQueue.waitUntilAllOperationsAreFinished ()
//  rawObjectArray.sort { $0.index < $1.index }
//  appendDocumentFileOperationInfo ("read \(rawObjectArray.count) objects done with \(pendingOperationCount) pending ops")
  appendDocumentFileOperationInfo ("read \(rawObjectArray.count) objects done")
//--- Setup toOne
  let scannerData = ioDataScanner.data
  for rawObject in rawObjectArray {
    let valueDictionary = rawObject.propertyDictionary
    let managedObject = rawObject.object
    managedObject.setUpToOneRelationshipsWithTextDictionary (valueDictionary, rawObjectArray, scannerData)
  }
  appendDocumentFileOperationInfo ("setup toOne done")
//--- Setup toMany
  for rawObject in rawObjectArray {
    let valueDictionary = rawObject.propertyDictionary
    let managedObject = rawObject.object
    managedObject.setUpToManyRelationshipsWithTextDictionary (valueDictionary, rawObjectArray, scannerData)
  }
  appendDocumentFileOperationInfo ("setup toMany done")
//--- Scanner error ?
  if !ioDataScanner.ok () {
    let dictionary = [
      "Cannot Open Document" : NSLocalizedDescriptionKey,
      "The file has an invalid format" : NSLocalizedRecoverySuggestionErrorKey
    ]
    throw NSError (domain: Bundle.main.bundleIdentifier!, code: 1, userInfo: dictionary)
  }
//--- Analyze read data
  if ioDataScanner.ok (), rawObjectArray.count > 0 {
    let rootObject = rawObjectArray [0].object
    return EBDocumentData (
      documentMetadataStatus: metadataStatus,
      documentMetadataDictionary: metadataDictionary,
      documentRootObject: rootObject,
      documentFileFormat: .textual
    )
  }else{
    let dictionary = [
      "Cannot Open Document" :  NSLocalizedDescriptionKey,
      "Root object cannot be read" :  NSLocalizedRecoverySuggestionErrorKey
    ]
    throw NSError (domain: Bundle.main.bundleIdentifier!, code: 1, userInfo: dictionary)
  }
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

@MainActor func dataForTextualSaveOperation (from inDocumentData : EBDocumentData) throws -> Data {
//--- First line: PM-TEXT-FORMAT
  var fileStringData = Data ()
  fileStringData.append (ascii: .P)
  fileStringData.append (ascii: .M)
  fileStringData.append (ascii: .minus)
  fileStringData.append (ascii: .T)
  fileStringData.append (ascii: .E)
  fileStringData.append (ascii: .X)
  fileStringData.append (ascii: .T)
  fileStringData.append (ascii: .minus)
  fileStringData.append (ascii: .F)
  fileStringData.append (ascii: .O)
  fileStringData.append (ascii: .R)
  fileStringData.append (ascii: .M)
  fileStringData.append (ascii: .A)
  fileStringData.append (ascii: .T)
  fileStringData.append (ascii: .lineFeed)
//--- Append status
  fileStringData.append (base62Encoded: Int (inDocumentData.documentMetadataStatus))
  fileStringData.append (ascii: .lineFeed)
//--- Append metadata dictionary
  // .sortedKeys is only available in 10.13
  let textMetaData = try JSONSerialization.data (withJSONObject: inDocumentData.documentMetadataDictionary, options: [])
  fileStringData += textMetaData
  fileStringData.append (ascii: .lineFeed)
//--- Build class index dictionary
  let objectArray = collectAndPrepareObjectsForSaveOperation (fromRoot: inDocumentData.documentRootObject)
  var classDictionary = [String : Int] ()
  var classDescriptionString = ""
  for object in objectArray {
    let key = String (describing: type (of: object as Any))
    if classDictionary [key] == nil {
      classDictionary [key] = classDictionary.count
      classDescriptionString += "$" + key + "\n"
      object.appendPropertyNamesTo (&classDescriptionString)
    }
  }
  fileStringData += classDescriptionString.data (using: .utf8)!
//--- Save data
  for object in objectArray {
    let key = String (describing: type (of: object as Any))
    let classIndex = classDictionary [key]!
  //  Swift.print ("\(classIndex)")
    fileStringData.append (ascii: .at)
    fileStringData.append (base62Encoded: classIndex)
    fileStringData.append (ascii: .lineFeed)
    object.appendPropertyValuesTo (&fileStringData)
  }
//---
//   Swift.print ("Text Saving \(Int (Date ().timeIntervalSince (start) * 1000.0)) ms")
  return fileStringData
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
