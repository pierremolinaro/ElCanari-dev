//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  THIS FILE IS GENERATED BY EASY BINDINGS, DO NOT MODIFY IT
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

import Cocoa

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

//fileprivate func update <T : Hashable> (currentSet ioCurrentSet : inout Set <T>,
//                                        fromNewArray inNewArray : [T],
//                                        oldArray inOldArray : [T]) -> (Bool, Set <T>, Set <T>) {
//  let equalModels = inNewArray == inOldArray
//  var addedSet = Set <T> ()
//  var removedSet = Set <T> ()
//  if !equalModels {
//    let newSet = Set (inNewArray)
//    if ioCurrentSet != newSet {
//      let oldSet = ioCurrentSet
//      ioCurrentSet = newSet
//      removedSet = oldSet.subtracting (newSet)
//      addedSet = newSet.subtracting (oldSet)
//    }
//  }
//  return (equalModels, addedSet, removedSet)
//}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

fileprivate func update <T : Hashable> (currentSet ioCurrentSet : inout Set <T>,
                                        fromNewArray inNewArray : [T],
                                        oldArray inOldArray : [T]) -> (Bool, Set <T>, Set <T>) {
  var addedSet = Set <T> ()
  var removedSet = Set <T> ()
//--- Model did change ?
  var modelsAreEqual = inNewArray.count == inOldArray.count
  var idx = 0
  while modelsAreEqual && (idx < inNewArray.count) {
    modelsAreEqual = inNewArray [idx] == inOldArray [idx]
    idx += 1
  }
//---
  if !modelsAreEqual {
    var setAreEqual = ioCurrentSet.count == inNewArray.count
    var newSet = Set <T> (minimumCapacity: inNewArray.count)
    for object in inNewArray {
      newSet.insert (object)
      if !ioCurrentSet.contains (object) {
        setAreEqual = false
        addedSet.insert (object)
      }
    }
    if !setAreEqual {
      let oldSet = ioCurrentSet
      ioCurrentSet = newSet
      removedSet = oldSet.subtracting (newSet)
    }
  }
  return (modelsAreEqual, addedSet, removedSet)
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//    ReadOnlyAbstractArrayProperty
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class ReadOnlyAbstractArrayProperty <T : Hashable> : ReadOnlyAbstractGenericRelationshipProperty {

  //····················································································································
  // Abstract methods
  //····················································································································

  var selection : EBSelection < [T] > { get { return .empty } }  // Abstract method

  //····················································································································

  var propval : [T] { return [] } // Abstract method

  //····················································································································

  final var propset : Set <T> { return self.mInternalSetValue }

  //····················································································································
  //  Internal value
  //····················································································································

  final var internalSetValue : Set <T> { return self.mInternalSetValue }

  private final var mInternalSetValue = Set <T> () // Requires T to be hashable

  internal final var mInternalArrayValue = [T] () {
    didSet {
      let (equalModels, addedSet, removedSet) = update (currentSet: &self.mInternalSetValue, fromNewArray: self.mInternalArrayValue, oldArray: oldValue)
      if !equalModels {
        if self.mInternalArrayValue.count != oldValue.count {
          self.count_property.postEvent ()
        }
        self.postEvent ()
        self.notifyModelDidChangeFrom (oldValue: oldValue)
        self.notifyModelDidChange ()
   //     let (modelDidChange, addedSet, removedSet) = update (currentSet: &self.mInternalSetValue, fromNewArray: self.mInternalArrayValue, oldArray: oldValue)
        if !addedSet.isEmpty || !removedSet.isEmpty {
          self.updateObservers (removedSet: removedSet, addedSet: addedSet)
        }
//        let newSet = Set (self.mInternalArrayValue)
//        if self.mInternalSetValue != newSet {
//          let oldSet = self.mInternalSetValue
//          self.mInternalSetValue = newSet
//          let removedSet = oldSet.subtracting (newSet)
//          let addedSet = newSet.subtracting (oldSet)
//          self.updateObservers (removedSet: removedSet, addedSet: addedSet)
//        }
      }
    }
  }

  //····················································································································

  internal func notifyModelDidChangeFrom (oldValue inOldValue : [T]) {
  }

  //····················································································································

  internal func updateObservers (removedSet inRemovedSet : Set <T>, addedSet inAddedSet : Set <T>) {
  }

  //····················································································································
  //  count property
  //····················································································································

  final var count_property = EBTransientProperty_Int ()

  //····················································································································
  //  init
  //····················································································································

  override init () {
    super.init ()
    self.count_property.mReadModelFunction = { [weak self] in
      if let me = self {
        switch me.selection {
        case .empty :
          return .empty
        case .multiple :
          return .multiple
        case .single (let v) :
          return .single (v.count)
        }
      }else{
        return .empty
      }
    }
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
