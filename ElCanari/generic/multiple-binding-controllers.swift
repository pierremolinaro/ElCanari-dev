//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  THIS FILE IS GENERATED BY EASY BINDINGS, DO NOT MODIFY IT
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

import Cocoa

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

protocol HiddenEBProtocol : AnyObject {
  var isHidden : Bool { get set }
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

extension NSView : HiddenEBProtocol {
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   MultipleBindingController_hidden
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

final class MultipleBindingController_hidden : EBOutletEvent {

  private weak var mOutlet : HiddenEBProtocol? = nil

  //····················································································································

  init (computeFunction inExpression : EBMultipleBindingBooleanExpression,
        outlet inOutlet : HiddenEBProtocol?) {
    self.mOutlet = inOutlet
    super.init ()
    self.mEventCallBack = { [weak self] in self?.updateOutlet (inExpression.compute ()) }
    var modelArray = [EBObservableObjectProtocol] ()
    inExpression.addModelsTo (&modelArray)
    for observedModel in modelArray {
      observedModel.addEBObserver (self)
    }
  }

  //····················································································································

   private func updateOutlet (_ inSelection : EBSelection <Bool>) {
    switch inSelection {
    case .single (let b) :
      self.mOutlet?.isHidden = b
    default :
      self.mOutlet?.isHidden = false
    }
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   MultipleBindingController_enabled
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

protocol EnabledMultipleBindingProtocol : AnyObject {
  func enableFromEnableBinding (_ inEnable : Bool)
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

final class MultipleBindingController_enabled : EBOutletEvent {

  private weak var mOutlet : EnabledMultipleBindingProtocol? = nil

  //····················································································································

  init (computeFunction inExpression : EBMultipleBindingBooleanExpression,
        outlet inOutlet : EnabledMultipleBindingProtocol?) {
    self.mOutlet = inOutlet
    super.init ()
    var modelArray = [EBObservableObjectProtocol] ()
    inExpression.addModelsTo (&modelArray)
    for observedModel in modelArray {
      observedModel.addEBObserver (self)
    }
    self.mEventCallBack = { [weak self] in self?.updateOutlet (inExpression.compute ()) }
  }

  //····················································································································

  private func updateOutlet (_ inModel : EBSelection <Bool>) {
    switch inModel {
    case .single (let b) :
      self.mOutlet?.enableFromEnableBinding (b)
    default :
      self.mOutlet?.enableFromEnableBinding (false)
    }
  }

  //····················································································································

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum MultipleBindingBooleanOperation {
  case or
  case and
  case xor
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum MultipleBindingIntegerOperation {
  case eq
  case ne
  case lt
  case le
  case gt
  case ge
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

indirect enum EBMultipleBindingBooleanExpression {
  case alwaysTrue
  case boolcmp (EBMultipleBindingBooleanExpression, MultipleBindingBooleanOperation, EBMultipleBindingBooleanExpression)
  case intcmp  (EBMultipleBindingIntegerExpression, MultipleBindingIntegerOperation, EBMultipleBindingIntegerExpression)
  case not  (EBMultipleBindingBooleanExpression)
  case prop (EBObservableProperty <Bool>)

  func addModelsTo (_ ioModelArray : inout [EBObservableObjectProtocol]) {
    switch self {
    case .alwaysTrue :
      ()
    case .boolcmp (let left, _, let right) :
      left.addModelsTo (&ioModelArray)
      right.addModelsTo (&ioModelArray)
    case .intcmp (let left, _, let right) :
      left.addModelsTo (&ioModelArray)
      right.addModelsTo (&ioModelArray)
    case .not (let bindingExp) :
      bindingExp.addModelsTo (&ioModelArray)
    case .prop  (let model) :
      ioModelArray.append (model)
    }
  }

  func compute () -> EBSelection <Bool> {
    switch self {
    case .alwaysTrue :
      return .single (true)
    case .boolcmp (let left, let op, let right) :
      let leftSelection = left.compute ()
      let rightSelection = right.compute ()
      switch (leftSelection, rightSelection) {
      case (.empty, _), (_, .empty) :
        return .empty
      case (_, .multiple), (.multiple, _) :
        return .multiple
      case (.single (let v), .single (let w)) :
        switch op {
        case .and :
          return .single (v && w)
        case .or :
          return .single (v || w)
        case .xor :
          return .single (v != w)
        }
      }
    case .intcmp (let left, let op, let right) :
      let leftSelection = left.compute ()
      let rightSelection = right.compute ()
      switch (leftSelection, rightSelection) {
      case (.empty, _), (_, .empty) :
        return .empty
      case (_, .multiple), (.multiple, _) :
        return .multiple
      case (.single (let v), .single (let w)) :
        switch op {
        case .eq :
          return .single (v == w)
        case .ne :
          return .single (v != w)
        case .lt :
          return .single (v < w)
        case .le :
          return .single (v <= w)
        case .gt :
          return .single (v > w)
        case .ge :
          return .single (v >= w)
        }
      }
    case .not (let bindingExp) :
      let selection = bindingExp.compute ()
      switch selection {
      case .empty :
        return .empty
      case .single (let v) :
        return .single (!v)
      case .multiple :
        return .multiple
      }
    case .prop  (let model) :
      return model.selection
    }
  }

}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum EBMultipleBindingIntegerExpression {
  case literalInt (Int)
  case prop (EBObservableProperty <Int>)

  func addModelsTo (_ ioModelArray : inout [EBObservableObjectProtocol]) {
    switch self {
    case .literalInt :
      ()
    case .prop (let model) :
      ioModelArray.append (model)
    }
  }

  func compute () -> EBSelection <Int> {
    switch self {
    case .literalInt (let v) :
      return .single (v)
    case .prop (let model) :
      return model.selection
    }
  }
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

//class EBMultipleBindingBooleanExpression : EBUserClassNameProtocol {
//
//  //····················································································································
//
//  init () {
//    noteObjectAllocation (self)
//  }
//
//  //····················································································································
//
//  deinit {
//    noteObjectDeallocation (self)
//  }
//
//  //····················································································································
//
//  func addModelsTo (_ ioModelArray : inout [EBObservableObjectProtocol]) {
//  }
//
//  //····················································································································
//
//  func compute () -> EBSelection <Bool> {
//     return .empty
//  }
//
//  //····················································································································
//
//  class MultipleBindingProp : EBMultipleBindingBooleanExpression {
//
//    private weak var mProperty : EBObservableProperty <Bool>?
//
//    init (_ inProperty : EBObservableProperty <Bool>) {
//      self.mProperty = inProperty
//    }
//
//    override func addModelsTo (_ ioModelArray : inout [EBObservableObjectProtocol]) {
//      if let property = self.mProperty {
//        ioModelArray.append (property)
//      }
//    }
//
//    override func compute () -> EBSelection <Bool> {
//      self.mProperty?.selection ?? .empty
//    }
//
//  }
//
//  //····················································································································
//
//}
//
////——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//
//class EBMultipleBindingIntegerExpression : EBUserClassNameProtocol {
//
//  //····················································································································
//
//  init () {
//    noteObjectAllocation (self)
//  }
//
//  //····················································································································
//
//  deinit {
//    noteObjectDeallocation (self)
//  }
//
//  //····················································································································
//
//  func addModelsTo (_ ioModelArray : inout [EBObservableObjectProtocol]) {
//  }
//
//  //····················································································································
//
//  func compute () -> EBSelection <Int> {
//     return .empty
//  }
//
//  //····················································································································
//
//  class MultipleBindingProp : EBMultipleBindingIntegerExpression {
//
//    private weak var mProperty : EBObservableProperty <Int>?
//
//    init (_ inProperty : EBObservableProperty <Int>) {
//      self.mProperty = inProperty
//    }
//
//    override func addModelsTo (_ ioModelArray : inout [EBObservableObjectProtocol]) {
//      if let property = self.mProperty {
//        ioModelArray.append (property)
//      }
//    }
//
//    override func compute () -> EBSelection <Int> {
//      self.mProperty?.selection ?? .empty
//    }
//
//  }
//
//  //····················································································································
//
//}
//
////——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//
//class MultipleBindingNot : EBMultipleBindingBooleanExpression {
//
//  //····················································································································
//
//  private let mExpression : EBMultipleBindingBooleanExpression
//
//  //····················································································································
//
//  init (_ inExpression : EBMultipleBindingBooleanExpression) {
//    self.mExpression = inExpression
//  }
//
//  //····················································································································
//
//  override func addModelsTo (_ ioModelArray : inout [EBObservableObjectProtocol]) {
//    self.mExpression.addModelsTo (&ioModelArray)
//  }
//
//  //····················································································································
//
//  override func compute () -> EBSelection <Bool> {
//     switch self.mExpression.compute () {
//     case .empty :
//       return .empty
//     case .multiple :
//       return .multiple
//     case .single (let v) :
//       return .single (!v)
//     }
//  }
//
//  //····················································································································
//
//}
//
////——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//
//class MultipleBindingLiteralInt : EBMultipleBindingIntegerExpression {
//
//  //····················································································································
//
//  private let mValue : Int
//
//  //····················································································································
//
//  init (_ inValue : Int) {
//    self.mValue = inValue
//  }
//
//  //····················································································································
//
//  override func compute () -> EBSelection <Int> {
//    return .single (self.mValue)
//  }
//
//  //····················································································································
//
//}
//
////——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//
//class MultipleBindingBoolOp : EBMultipleBindingBooleanExpression {
//
//  //····················································································································
//
//  private let mLeft : EBMultipleBindingBooleanExpression
//  private let mOp : MultipleBindingBooleanOperation
//  private let mRight : EBMultipleBindingBooleanExpression
//
//  //····················································································································
//
//  init (_ inLeft : EBMultipleBindingBooleanExpression,
//        _ inOp : MultipleBindingBooleanOperation,
//        _ inRight : EBMultipleBindingBooleanExpression) {
//    self.mLeft = inLeft
//    self.mOp = inOp
//    self.mRight = inRight
//  }
//
//  //····················································································································
//
//  override func addModelsTo (_ ioModelArray : inout [EBObservableObjectProtocol]) {
//    self.mLeft.addModelsTo (&ioModelArray)
//    self.mRight.addModelsTo (&ioModelArray)
//  }
//
//  //····················································································································
//
//  override func compute () -> EBSelection <Bool> {
//     switch (self.mLeft.compute (), self.mRight.compute ()) {
//     case (.empty, _) :
//       return .empty
//     case (_, .empty) :
//       return .empty
//     case (.multiple, _) :
//       return .multiple
//     case (_, .multiple) :
//       return .multiple
//     case (.single (let left), .single (let right)) :
//        switch self.mOp {
//        case .or :
//          return .single (left || right)
//        case .and :
//          return .single (left && right)
//        case .xor :
//          return .single (left != right)
//        }
//     }
//  }
//
//  //····················································································································
//
//}
//
////——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//
//class MultipleBindingIntCmp : EBMultipleBindingBooleanExpression {
//
//  //····················································································································
//
//  private let mLeft : EBMultipleBindingIntegerExpression
//  private let mOp : MultipleBindingIntegerOperation
//  private let mRight : EBMultipleBindingIntegerExpression
//
//  //····················································································································
//
//  init (_ inLeft : EBMultipleBindingIntegerExpression,
//        _ inOp : MultipleBindingIntegerOperation,
//        _ inRight : EBMultipleBindingIntegerExpression) {
//    self.mLeft = inLeft
//    self.mOp = inOp
//    self.mRight = inRight
//  }
//
//  //····················································································································
//
//  override func addModelsTo (_ ioModelArray : inout [EBObservableObjectProtocol]) {
//    self.mLeft.addModelsTo (&ioModelArray)
//    self.mRight.addModelsTo (&ioModelArray)
//  }
//
//  //····················································································································
//
//  override func compute () -> EBSelection <Bool> {
//     switch (self.mLeft.compute (), self.mRight.compute ()) {
//     case (.empty, _) :
//       return .empty
//     case (_, .empty) :
//       return .empty
//     case (.multiple, _) :
//       return .multiple
//     case (_, .multiple) :
//       return .multiple
//     case (.single (let left), .single (let right)) :
//        switch self.mOp {
//        case .eq :
//          return .single (left == right)
//        case .ne :
//          return .single (left != right)
//        case .lt :
//          return .single (left < right)
//        case .le :
//          return .single (left <= right)
//        case .gt :
//          return .single (left > right)
//        case .ge :
//          return .single (left >= right)
//        }
//     }
//  }
//
//  //····················································································································
//
//}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
