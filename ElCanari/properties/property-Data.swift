//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//  THIS FILE IS GENERATED BY EASY BINDINGS, DO NOT MODIFY IT
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

import AppKit

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
//   Scalar property Data
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

typealias EBReadOnlyProperty_Data    = EBObservableProperty <Data>
typealias EBTransientProperty_Data   = EBGenericTransientProperty <Data>
typealias EBReadWriteProperty_Data   = EBObservableMutableProperty <Data>
typealias EBComputedProperty_Data    = EBGenericComputedProperty <Data>
typealias EBStoredProperty_Data      = EBGenericStoredProperty <Data>
typealias EBPreferencesProperty_Data = EBGenericPreferenceProperty <Data>

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func values_Data_are_ordered (_ inLeft : Data,
                              _ inAscending : Bool,
                              _ inRight : Data) -> Bool {
  let left  = inAscending ? inLeft  : inRight
  let right = inAscending ? inRight : inLeft
  return left < right
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

@MainActor func compare_Data_properties (_ inLeft : EBReadOnlyProperty_Data,
                                         _ inAscending : Bool,
                                         _ inRight : EBReadOnlyProperty_Data) -> ComparisonResult {
  let left  = inAscending ? inLeft  : inRight
  let right = inAscending ? inRight : inLeft
  switch left.selection {
  case .empty :
    switch right.selection {
    case .empty :
      return .orderedSame
    default:
      return .orderedAscending
    }
  case .multiple :
    switch right.selection {
    case .empty :
      return .orderedDescending
    case .multiple :
      return .orderedSame
   case .single (_) :
      return .orderedAscending
   }
 case .single (let currentValue) :
    switch right.selection {
    case .empty, .multiple :
      return .orderedDescending
    case .single (let otherValue) :
      if currentValue < otherValue {
        return .orderedAscending
      }else if currentValue > otherValue {
        return .orderedDescending
      }else{
        return .orderedSame
      }
    }
  }
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
