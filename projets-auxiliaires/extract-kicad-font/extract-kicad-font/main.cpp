//
//  main.cpp
//  extract-kicad-font
//
//  Created by Pierre Molinaro on 01/09/2018.
//  Copyright © 2018 Pierre Molinaro. All rights reserved.
//
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#include <iostream>
#include <vector>

using namespace std ;

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

static const char separator [] =
"//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————\n\n" ;

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#include "newstroke_font.h"

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

typedef struct {
  int x ;
  int y ;
} VECTOR2D ;

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
// From kicad source stroke_font.cpp
//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

static void loadNewStrokeFont (FILE * f, const char * const aNewStrokeFont [], const int inIndex) {
  fprintf (f, "fileprivate func enterCharacter%04x (_ ioDict : inout BoardFontDictionary) {\n", inIndex + ' ') ;
//  fprintf (f, "//--- Character \\u%04x\n", wchar_t (inIndex + ' ')) ;

  const wchar_t s = inIndex + ' ' ;
  printf ("Character #%d: %C\n", inIndex, s) ;
  int glyphStartX = 0 ;
  int glyphEndX = 0 ;
  bool penDown = false ;
  VECTOR2D point = {0, 0} ;
  int i = 0 ;
  bool hasSegment = false ;

  while (aNewStrokeFont [inIndex] [i]) {
    char coordinate[2] = { 0, } ;

    for (int k = 0 ; k < 2 ; k++) {
      coordinate [k] = aNewStrokeFont [inIndex] [i + k] ;
    }

    if (i < 2) { // The first two values contain the width of the char
      glyphStartX = coordinate [0] - 'R' ;
      glyphEndX   = coordinate [1] - 'R' ;
      cout << "  Start " << glyphStartX << ", end " << glyphEndX << endl ;
    }else if ((coordinate[0] == ' ') && (coordinate[1] == 'R')) {
      penDown = false ;
    }else{
      VECTOR2D newPoint = {0, 0} ;
      // In stroke font, coordinates values are coded as <value> + 'R',
      // <value> is an ASCII char.
      // therefore every coordinate description of the Hershey format has an offset,
      // it has to be subtracted
      // Note:
      //  * the stroke coordinates are stored in reduced form (-1.0 to +1.0),
      //    and the actual size is stroke coordinate * glyph size
      //  * a few shapes have a height slightly bigger than 1.0 ( like '{' '[' )
      newPoint.x = coordinate[0] - 'R' - glyphStartX ;
      #define FONT_OFFSET (-10)
      // FONT_OFFSET is here for historical reasons, due to the way the stroke font
      // was built. It allows shapes coordinates like W M ... to be >= 0
      // Only shapes like j y have coordinates < 0
      newPoint.y = coordinate[1] - 'R' + FONT_OFFSET ;
      // cout << "  (" << newPoint.x << ", " << newPoint.y << ")" << endl ;
      if (penDown) {
        if (!hasSegment) {
          hasSegment = true ;
          fprintf (f, "  var segments = [BoardCharSegment] ()\n") ;
        }
        cout << "  line (" << point.x << ", " << point.y << ") --> (" << newPoint.x << ", " << newPoint.y << ")" << endl ;
        fprintf (f, "  segments.append (BoardCharSegment (x1: %d, y1: %d, x2: %d, y2: %d))\n", point.x, point.y, newPoint.x, newPoint.y) ;
      }else{
        penDown = true ;
      }
      point = newPoint ;
    }
    i += 2 ;
  }
  const int advancement = glyphEndX - glyphStartX ;
  if (hasSegment || (advancement > 0)) {
    fprintf (f,
             "  ioDict [%u] = BoardFontCharacter (advancement: %d, segments: %s)\n",
             inIndex + ' ',
             advancement,
             hasSegment ? "segments" : "[]"
    ) ;
  }
  fprintf (f, "}\n\n") ;
  fprintf (f, separator) ;
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

int main (int argc, const char * argv []) {
  printf ("Font Source Buffer size: %d bytes\n", newStrokeFontBufferSize ()) ;
  const char * fileName = "kicad-font.swift" ;
  FILE * f = fopen (fileName, "wt") ;
  fprintf (f, "//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————\n") ;
  fprintf (f, "//  This file has been generated by extract-kicad-font tool\n") ;
  fprintf (f, separator) ;
  fprintf (f, "import Foundation\n\n") ;
  fprintf (f, separator) ;
  fprintf (f, "func kicadFont () -> BoardFontDictionary {\n") ;
  fprintf (f, "  var dict = BoardFontDictionary ()\n") ;
  fprintf (f, "  enter0 (&dict)\n") ;
  fprintf (f, "  enter1 (&dict)\n") ;
  fprintf (f, "  enter2 (&dict)\n") ;
  fprintf (f, "  enter3 (&dict)\n") ;
  fprintf (f, "  enter4 (&dict)\n") ;
  fprintf (f, "  enter5 (&dict)\n") ;
  fprintf (f, "  enter6 (&dict)\n") ;
  fprintf (f, "  return dict\n") ;
  fprintf (f, "}\n\n") ;
  fprintf (f, separator) ;

  std::vector <int> chars ;
  fprintf (f, "fileprivate func enter0 (_ ioDict : inout BoardFontDictionary) {\n") ;
  for (int idx = ' ' ; idx <= '~' ; idx++) {
    chars.push_back (idx) ;
    fprintf (f, "  enterCharacter%04x (&ioDict)\n", idx) ;
  }
  fprintf (f, "}\n\n") ;
  fprintf (f, separator) ;
  fprintf (f, "fileprivate func enter1 (_ ioDict : inout BoardFontDictionary) {\n") ;
  for (int idx = 0xA0 ; idx <= 0x2FF ; idx++) {
    chars.push_back (idx) ;
    fprintf (f, "  enterCharacter%04x (&ioDict)\n", idx) ;
  }
  fprintf (f, "}\n\n") ;
  fprintf (f, separator) ;
  fprintf (f, "fileprivate func enter2 (_ ioDict : inout BoardFontDictionary) {\n") ;
  for (int idx = 0x370 ; idx <= 0x523 ; idx++) {
    chars.push_back (idx) ;
    fprintf (f, "  enterCharacter%04x (&ioDict)\n", idx) ;
  }
  fprintf (f, "}\n\n") ;
  fprintf (f, separator) ;
  fprintf (f, "fileprivate func enter3 (_ ioDict : inout BoardFontDictionary) {\n") ;
  for (int idx = 0x1D00 ; idx <= 0x1D7F ; idx++) {
    chars.push_back (idx) ;
    fprintf (f, "  enterCharacter%04x (&ioDict)\n", idx) ;
  }
  fprintf (f, "}\n\n") ;
  fprintf (f, separator) ;
  fprintf (f, "fileprivate func enter4 (_ ioDict : inout BoardFontDictionary) {\n") ;
  for (int idx = 0x1E00 ; idx <= 0x20B5 ; idx++) {
    chars.push_back (idx) ;
    fprintf (f, "  enterCharacter%04x (&ioDict)\n", idx) ;
  }
  fprintf (f, "}\n\n") ;
  fprintf (f, separator) ;
  fprintf (f, "fileprivate func enter5 (_ ioDict : inout BoardFontDictionary) {\n") ;
  for (int idx = 0x2190 ; idx <= 0x23E7 ; idx++) {
    chars.push_back (idx) ;
    fprintf (f, "  enterCharacter%04x (&ioDict)\n", idx) ;
  }
  fprintf (f, "}\n\n") ;
  fprintf (f, separator) ;
  fprintf (f, "fileprivate func enter6 (_ ioDict : inout BoardFontDictionary) {\n") ;
  for (int idx = 0x25A0 ; idx <= 0x25FE ; idx++) {
    chars.push_back (idx) ;
    fprintf (f, "  enterCharacter%04x (&ioDict)\n", idx) ;
  }
  fprintf (f, "}\n\n") ;
  fprintf (f, separator) ;
  for (std::vector<int>::iterator it = chars.begin(); it != chars.end(); ++it) {
    loadNewStrokeFont (f, newstroke_font, *it - ' ') ;
  }
  fclose (f) ;
  return 0 ;
}

//——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
